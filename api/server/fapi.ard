use ard/async
use ard/decode
use ard/duration
use ard/http
use ard/io
use ard/maybe
use ard/sql

use maestro/cache
use maestro/config

// API-Football module - consolidates all external API calls to v3.football.api-sports.io

fn flatten_values(map: [Str:Str]) Str {
  mut str = ""
  for key, value in map {
    str =+ " {value}"
  }
  str
}

fn join_strs(list: [Str]) Str {
  mut str = ""
  for it in list {
    str =+ " " + it
  }
  str
}

private fn fetch(path: Str) http::Response!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/"+path,
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  let res = try http::send(req) -> err { Result::err("Error fetching {path}: {err}") }
  Result::ok(res)
}

fn send_request(path: Str) Dynamic!Str {
  mut res = try fetch(path)

  mut attempts = 1
  while attempts < 3 and res.status == 429 {
    // Rate limited - no Retry-After header from API-Football
    // Per-minute limit resets quickly, so wait 2 seconds and retry
    async::sleep(duration::from_seconds(2))
    attempts =+ 1
    res = try fetch(path)
  }

  match res.status {
    200 => {
      let body = try decode::from_json(res.body) -> found {
        Result::err("Unable to parse response body as JSON for {path}. Found {found}")
      }

      // the API is documented as returning a list of strings but in reality, does something different:
      // when no errors - it's an empty list
      // when there are errors - it's a map of field name to message string
      let parse_errors = decode::one_of(decode::list(decode::string), [fn(data: Dynamic) [Str]![decode::Error] {
        mut msgs: [Str] = []
        decode::map(decode::string, fn(v: Dynamic) Void![decode::Error] {
          match decode::string(v) {
            ok => msgs.push(ok),
            err => (),
          }
          Result::ok(())
        })
        Result::ok(msgs)
      }])

      let errors = try decode::run(body, decode::field("errors", parse_errors)) -> errs {
        Result::err("Bad Request. Couldn't decode fapi errors: {errs.at(0)}")
      }

      match errors.size() > 0 {
        true => Result::err(join_strs(errors)),
        false => Result::ok(body)
      }
    },
    _ => Result::err("Bad request ({path}). Received {res.status}")
  }
}

fn get_fixture(db: sql::Database, id: Int) Dynamic!Str {
  let id_str = id.to_str()
  let body = match cache::get(db, "fixture", id_str) {
    body => body,
    _ => {
      let body = try send_request("fixtures?id={id}")
      cache::set(db, "fixture", id_str, body)
      body
    }
  }

  let entry = try decode::run(body, decode::field("response", decode::at(0, decode::dynamic))) -> errs {
    Result::err("Could not decode response[0] in data for fixture({id}): {errs.at(0)}")
  }
  Result::ok(entry)
}

fn get_team(db: sql::Database, id: Int) Dynamic!Str {
  let id_str = id.to_str()
  let body = match cache::get(db, "team", id_str) {
    body => body,
    _ => {
      let body = try send_request("teams?id={id}")
      cache::set(db, "team", id_str, body)
      body
    }
  }
  let entry = try decode::run(body, decode::field("response", decode::at(0, decode::dynamic))) -> errs {
    Result::err("Could not decode response[0] in data for team({id}): {errs.at(0)}")
  }
  Result::ok(entry)
}

fn get_odds(db: sql::Database, fixture_id: Int) Dynamic!Str {
  let id_str = fixture_id.to_str()
  let cached_body = cache::get(db, "odds", id_str)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("odds?fixture={fixture_id}&bookmaker=8")
      cache::set(db, "odds", id_str, body)
      Result::ok(body)
    }
  }
}

fn get_predictions(db: sql::Database, fixture_id: Int) Dynamic!Str {
  let id_str = fixture_id.to_str()
  let cached_body = cache::get(db, "predictions", id_str)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("predictions?fixture={fixture_id}")
      cache::set(db, "predictions", id_str, body)
      Result::ok(body)
    }
  }
}

fn get_league_current_season(db: sql::Database, league_id: Int) Int!Str {
  let body = try send_request("leagues?id={league_id}&current=true")
  let dig_out_season = decode::field("response", decode::at(0, decode::field("seasons", decode::at(0, decode::field("year", decode::int)))))
  let season = try dig_out_season(body) -> errs { Result::err(errs.at(0).to_str()) }
  Result::ok(season)
}

fn get_league(db: sql::Database, league_id: Int) Dynamic!Str {
  let id_str = league_id.to_str()
  let cached_body = cache::get(db, "league", id_str)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("leagues?id={league_id}")
      cache::set(db, "league", id_str, body)
      Result::ok(body)
    }
  }
}

fn get_team_fixtures(db: sql::Database, team_id: Int, league_id: Int, season: Int) Dynamic!Str {
  let resource_id = "{team_id}:{league_id}:{season}"
  let cached_body = cache::get(db, "team_fixtures", resource_id)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("fixtures?team={team_id}&league={league_id}&season={season}")
      cache::set(db, "team_fixtures", resource_id, body)
      Result::ok(body)
    }
  }
}

fn get_team_played_fixtures(db: sql::Database, team_id: Int, league_id: Int, season: Int, last: Int?) [Dynamic]!Str {
  let resource_id = match last {
    l => "{team_id}:{league_id}:{season}:last{l}",
    _ => "{team_id}:{league_id}:{season}:all"
  }
  let cached_body = cache::get(db, "team_played_fixtures", resource_id)
  match cached_body {
    body => {
      let data = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Couldn't decode cached response: {errs.at(0)}")
      }
      Result::ok(data)
    },
    _ => {
      mut query = "team={team_id}&league={league_id}&season={season}&status=FT"
      match last {
        l => { query =+ "&last={l}" },
        _ => ()
      }
      let body = try send_request("fixtures?{query}")
      let data = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Couldn't decode response: {errs.at(0)}")
      }
      cache::set(db, "team_played_fixtures", resource_id, body)
      Result::ok(data)
    }
  }
}

fn get_today_fixtures(db: sql::Database, date: Str) Dynamic!Str {
  let cached_body = cache::get(db, "today_fixtures", date)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("fixtures?status=NS&timezone=America/New_York&date={date}")
      cache::set(db, "today_fixtures", date, body)
      Result::ok(body)
    }
  }
}

fn get_season_fixtures(db: sql::Database, league_id: Int, season: Int) [Dynamic]!Str {
  let resource_id = "{league_id}:{season}"
  let cached_body = cache::get(db, "season_fixtures", resource_id)
  match cached_body {
    body => {
      let entries = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Unable to decode response: {errs.at(0)}")
      }
      Result::ok(entries)
    },
    _ => {
      let body = try send_request("fixtures?league={league_id}&season={season}")
      let entries = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Unable to decode response: {errs.at(0)}")
      }
      cache::set(db, "season_fixtures", resource_id, body)
      Result::ok(entries)
    }
  }
}
