use ard/async
use ard/decode
use ard/duration
use ard/http
use ard/io
use ard/maybe
use ard/sql

use maestro/cache
use maestro/config

// API-Football module - consolidates all external API calls to v3.football.api-sports.io

fn join_strs(list: [Str]) Str {
  mut str = ""
  for it in list {
    str =+ " " + it
  }
  str
}

private fn fetch(path: Str) Dynamic!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/"+path,
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  mut attempts = 0
  mut data: Dynamic? = maybe::none()

  // make the request and check whether it receives data.
  // retries when rate limited and aborts if the request couldn't be completed.
  while data.is_none() and attempts < 3 {
    let response = try http::send(req) -> err { Result::err("Error fetching /{path}: {err}") }
    let body = try decode::from_json(response.body) -> found {
      Result::err("Unable to parse response body as JSON for \{path}. Found {found}")
    }

    // API-Football doesn't use a status code for rate limit errors. Everything is a 200 and errors are in
    // body.errors, which is a map ([Str:Str]).
    let has_rate_limit_key = fn (data: Dynamic) Bool![decode::Error] {
      let map = try decode::run(data, decode::map(decode::string, decode::dynamic)) -> _ { Result::ok(false) }
      Result::ok(map.has("rateLimit"))
    }
    let is_rate_limited = decode::run(body, decode::field("errors", has_rate_limit_key)).or(false)
    match is_rate_limited {
      true => {
        io::print("[fapi] Rate limit exceeded - (attempt: {attempts + 1}, path: /{path})")
        async::sleep(duration::from_seconds(30))
        attempts =+ 1
      },
      false => { data = maybe::some(body) }
    }
  }

  match data {
    d => Result::ok(d),
    _ => Result::err("Failed to fetch /{path} after {attempts} attempts")
  }
}

fn send_request(path: Str) Dynamic!Str {
  mut body = try fetch(path)

  // the API is documented as `body.errors` being a list of strings but there are two possibilities:
  // * request has no errors - .errors is an empty list
  // * request has errors - .errors ss a map of field name to message string
  let parse_errors = decode::one_of(decode::list(decode::string), [fn(data: Dynamic) [Str]![decode::Error] {
    mut msgs: [Str] = []
    decode::map(decode::string, fn(v: Dynamic) Void![decode::Error] {
      match decode::string(v) {
        ok => msgs.push(ok),
        err => (),
      }
      Result::ok(())
    })
    Result::ok(msgs)
  }])

  let errors = try decode::run(body, decode::field("errors", parse_errors)) -> errs {
    Result::err("Bad Request. Couldn't decode fapi errors: {errs.at(0)}")
  }

  match errors.size() > 0 {
    true => Result::err(join_strs(errors)),
    false => Result::ok(body)
  }
}

// todo: cache keys could simply be complete path - fixtures?id=2498

fn get_league_fixtures(db: sql::Database, league_id: Int, date: Str, season: Int) Dynamic!Str {
  let resource_id = "fixtures?league={league_id}&season={season}&date={date}"
  let cached_body = cache::get(db, "fixtures", resource_id)
  match cached_body {
    body => {
      let data = try decode::run(body, decode::field("response", decode::dynamic)) -> errs {
        Result::err("Couldn't decode cached response: {decode::flatten(errs)}")
      }
      Result::ok(data)
    },
    _ => {
      let body = try send_request(resource_id)
      let data = try decode::run(body, decode::field("response", decode::dynamic)) -> errs {
        Result::err("Couldn't decode response: {decode::flatten(errs)}")
      }
      cache::set(db, resource_id, resource_id, body)
      Result::ok(data)
    }
  }
}

fn get_fixture(db: sql::Database, id: Int) Dynamic!Str {
  let id_str = id.to_str()
  let body = match cache::get(db, "fixture", id_str) {
    body => body,
    _ => {
      let body = try send_request("fixtures?id={id}")
      cache::set(db, "fixture", id_str, body)
      body
    }
  }

  let entry = try decode::run(body, decode::field("response", decode::at(0, decode::dynamic))) -> errs {
    Result::err("Could not decode response[0] in data for fixture({id}): {errs.at(0)}")
  }
  Result::ok(entry)
}

fn get_team(db: sql::Database, id: Int) Dynamic!Str {
  let id_str = id.to_str()
  let body = match cache::get(db, "team", id_str) {
    body => body,
    _ => {
      let body = try send_request("teams?id={id}")
      cache::set(db, "team", id_str, body)
      body
    }
  }
  let entry = try decode::run(body, decode::field("response", decode::at(0, decode::dynamic))) -> errs {
    Result::err("Could not decode response[0] in data for team({id}): {errs.at(0)}")
  }
  Result::ok(entry)
}

fn get_odds(db: sql::Database, fixture_id: Int) Dynamic!Str {
  let id_str = fixture_id.to_str()
  let cached_body = cache::get(db, "odds", id_str)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("odds?fixture={fixture_id}&bookmaker=8")
      cache::set(db, "odds", id_str, body)
      Result::ok(body)
    }
  }
}

fn get_predictions(db: sql::Database, fixture_id: Int) Dynamic!Str {
  let id_str = fixture_id.to_str()
  let cached_body = cache::get(db, "predictions", id_str)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("predictions?fixture={fixture_id}")
      cache::set(db, "predictions", id_str, body)
      Result::ok(body)
    }
  }
}

// todo: use cache
fn get_league_current_season(db: sql::Database, league_id: Int) Int!Str {
  let body = try send_request("leagues?id={league_id}&current=true")
  let dig_out_season = decode::field("response", decode::at(0, decode::field("seasons", decode::at(0, decode::field("year", decode::int)))))
  let season = try dig_out_season(body) -> errs { Result::err(errs.at(0).to_str()) }
  Result::ok(season)
}

fn get_league(db: sql::Database, league_id: Int) Dynamic!Str {
  let id_str = league_id.to_str()
  let cached_body = cache::get(db, "league", id_str)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("leagues?id={league_id}")
      cache::set(db, "league", id_str, body)
      Result::ok(body)
    }
  }
}

fn get_team_fixtures(db: sql::Database, team_id: Int, league_id: Int, season: Int) Dynamic!Str {
  let resource_id = "{team_id}:{league_id}:{season}"
  let cached_body = cache::get(db, "team_fixtures", resource_id)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("fixtures?team={team_id}&league={league_id}&season={season}")
      cache::set(db, "team_fixtures", resource_id, body)
      Result::ok(body)
    }
  }
}

fn get_team_played_fixtures(db: sql::Database, team_id: Int, league_id: Int, season: Int, last: Int?) [Dynamic]!Str {
  let resource_id = match last {
    l => "{team_id}:{league_id}:{season}:last{l}",
    _ => "{team_id}:{league_id}:{season}:all"
  }
  let cached_body = cache::get(db, "team_played_fixtures", resource_id)
  match cached_body {
    body => {
      let data = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Couldn't decode cached response: {errs.at(0)}")
      }
      Result::ok(data)
    },
    _ => {
      mut query = "team={team_id}&league={league_id}&season={season}&status=FT"
      match last {
        l => { query =+ "&last={l}" },
        _ => ()
      }
      let body = try send_request("fixtures?{query}")
      let data = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Couldn't decode response: {errs.at(0)}")
      }
      cache::set(db, "team_played_fixtures", resource_id, body)
      Result::ok(data)
    }
  }
}

fn get_today_fixtures(db: sql::Database, date: Str) Dynamic!Str {
  let cached_body = cache::get(db, "today_fixtures", date)
  match cached_body {
    body => Result::ok(body),
    _ => {
      let body = try send_request("fixtures?status=NS&timezone=America/New_York&date={date}")
      cache::set(db, "today_fixtures", date, body)
      Result::ok(body)
    }
  }
}

fn get_season_fixtures(db: sql::Database, league_id: Int, season: Int) [Dynamic]!Str {
  let resource_id = "{league_id}:{season}"
  let cached_body = cache::get(db, "season_fixtures", resource_id)
  match cached_body {
    body => {
      let entries = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Unable to decode response: {errs.at(0)}")
      }
      Result::ok(entries)
    },
    _ => {
      let body = try send_request("fixtures?league={league_id}&season={season}")
      let entries = try decode::run(body, decode::field("response", decode::list(decode::dynamic))) -> errs {
        Result::err("Unable to decode response: {errs.at(0)}")
      }
      cache::set(db, "season_fixtures", resource_id, body)
      Result::ok(entries)
    }
  }
}
