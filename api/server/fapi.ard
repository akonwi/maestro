use ard/async
use ard/decode
use ard/duration
use ard/http
use ard/io
use ard/maybe
use ard/sql

use maestro/cache
use maestro/config

// API-Football module - consolidates all external API calls to v3.football.api-sports.io

fn join_strs(list: [Str]) Str {
  mut str = ""
  for it in list {
    str =+ " " + it
  }
  str
}

// makes requests and retries if necessary
private fn fetch(path: Str) Dynamic!Str {
  let req = http::Request{
    method: http::Method::Get,
    url: "https://v3.football.api-sports.io/"+path,
    headers: [
      "x-rapidapi-key": config::api_key(),
      "Accept": "application/json",
    ],
  }

  mut attempts = 0
  mut data: Dynamic? = maybe::none()

  // make the request and check whether it receives data.
  // retries when rate limited and aborts if the request couldn't be completed.
  while data.is_none() and attempts < 3 {
    let response = try http::send(req) -> err { Result::err("Error fetching /{path}: {err}") }
    let body = try decode::from_json(response.body) -> found {
      Result::err("Unable to parse response body as JSON for \{path}. Found {found}")
    }

    // API-Football doesn't use a status code for rate limit errors. Everything is a 200 and errors are in
    // body.errors, which is a map ([Str:Str]).
    let has_rate_limit_key = fn (data: Dynamic) Bool![decode::Error] {
      let map = try decode::run(data, decode::map(decode::string, decode::dynamic)) -> _ { Result::ok(false) }
      Result::ok(map.has("rateLimit"))
    }
    let is_rate_limited = decode::run(body, decode::field("errors", has_rate_limit_key)).or(false)
    match is_rate_limited {
      true => {
        io::print("[fapi] Rate limit exceeded - (attempt: {attempts + 1}, path: /{path})")
        async::sleep(duration::from_seconds(5))
        attempts =+ 1
      },
      false => { data = maybe::some(body) }
    }
  }

  match data {
    d => Result::ok(d),
    _ => Result::err("Failed to fetch /{path} after {attempts} attempts")
  }
}

// prepare and handle requests
// - parses returned errors
// - on successful requests, handles boilerplate parsing to dig out `body.response`
fn send_request(path: Str) Dynamic!Str {
  mut body = try fetch(path)

  // the API is documented as `body.errors` being a list of strings but there are two possibilities:
  // * request has no errors - .errors is an empty list
  // * request has errors - .errors ss a map of field name to message string
  let parse_errors = decode::one_of(decode::list(decode::string), [fn(data: Dynamic) [Str]![decode::Error] {
    mut msgs: [Str] = []
    decode::map(decode::string, fn(v: Dynamic) Void![decode::Error] {
      match decode::string(v) {
        ok => msgs.push(ok),
        err => (),
      }
      Result::ok(())
    })
    Result::ok(msgs)
  }])

  let errors = try decode::run(body, decode::field("errors", parse_errors)) -> errs {
    Result::err("Couldn't decode fapi errors: {decode::flatten(errs)}")
  }

  match errors.size() > 0 {
    true => Result::err(join_strs(errors)),
    false => {
      let data = try decode::run(body, decode::field("response", decode::dynamic)) -> errs {
        Result::err("Couldn't decode response: {decode::flatten(errs)}")
      }
      Result::ok(data)
    }
  }
}

fn get_league_fixtures(db: sql::Database, league_id: Int, date: Str, season: Int) Dynamic!Str {
  let path = "fixtures?league={league_id}&season={season}&date={date}"

  let data = try cache::get_or_set(db, path, send_request)
  Result::ok(data)
}

fn get_fixture(db: sql::Database, id: Int) Dynamic!Str {
  let path = "fixtures?id={id}"
  let data = try cache::get_or_set(db, path, send_request)
  let entry = try decode::run(data, decode::at(0, decode::dynamic)) -> errs {
    Result::err(decode::flatten(errs))
  }
  Result::ok(entry)
}

fn get_team(db: sql::Database, id: Int) Dynamic!Str {
  let path = "teams?id={id}"
  let data = try cache::get_or_set(db, path, send_request)
  let entry = try decode::run(data, decode::at(0, decode::dynamic)) -> errs {
    Result::err(decode::flatten(errs))
  }
  Result::ok(entry)
}

fn get_odds(db: sql::Database, fixture_id: Int) Dynamic!Str {
  let path = "odds?fixture={fixture_id}&bookmaker=8"
  cache::get_or_set(db, path, send_request)
}

fn get_predictions(db: sql::Database, fixture_id: Int) Dynamic!Str {
  let path = "predictions?fixture={fixture_id}"
  cache::get_or_set(db, path, send_request)
}

fn get_league_current_season(db: sql::Database, league_id: Int) Int!Str {
  let path = "leagues?id={league_id}&current=true"
  let data = try cache::get_or_set(db, path, send_request, cache::TTL_CURRENT_SEASON)
  let dig_out_season = decode::at(0, decode::field("seasons", decode::at(0, decode::field("year", decode::int))))
  let season = try dig_out_season(data) -> errs { Result::err(decode::flatten(errs)) }
  Result::ok(season)
}

fn get_league(db: sql::Database, league_id: Int) Dynamic!Str {
  let path = "leagues?id={league_id}"
  cache::get_or_set(db, path, send_request)
}

fn get_team_fixtures(db: sql::Database, team_id: Int, league_id: Int, season: Int) Dynamic!Str {
  let path = "fixtures?team={team_id}&league={league_id}&season={season}"
  cache::get_or_set(db, path, send_request)
}

fn get_team_played_fixtures(db: sql::Database, team_id: Int, league_id: Int, season: Int, last: Int?) [Dynamic]!Str {
  mut path = "fixtures?team={team_id}&league={league_id}&season={season}&status=FT"
  match last {
    l => { path =+ "&last={l}" },
    _ => ()
  }
  let data = try cache::get_or_set(db, path, send_request)
  let entries = try decode::run(data, decode::list(decode::dynamic)) -> errs {
    Result::err(decode::flatten(errs))
  }
  Result::ok(entries)
}

fn get_season_fixtures(db: sql::Database, league_id: Int, season: Int) [Dynamic]!Str {
  let path = "fixtures?league={league_id}&season={season}"
  let data = try cache::get_or_set(db, path, send_request)
  let entries = try decode::run(data, decode::list(decode::dynamic)) -> errs {
    Result::err(decode::flatten(errs))
  }
  Result::ok(entries)
}
