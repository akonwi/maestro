use ard/async
use ard/decode
use ard/duration
use ard/maybe
use ard/sql

use maestro/fapi
use maestro/fixtures
use maestro/leagues

struct Shots {
  total: Int
  per_game: Float,
  on_target: Int,
  on_target_per_game: Float,
  off_target: Int,
  off_target_per_game: Float,
  in_box: Int,
  in_box_per_game: Float,
  out_box: Int,
  out_box_per_game: Float,
  blocked: Int,
  blocked_per_game: Float,
}

struct Passes {
  total: Int,
  per_game: Float,
  completed: Int,
  completed_per_game: Float,
  accuracy: Float,
}

struct TeamMetrics {
  corners: Int,
  shots: Shots,
  passes: Passes,
  xg: Float,
  possession: Float,
}

fn TeamMetrics::new() TeamMetrics {
  TeamMetrics{
    corners: 0,
    shots: Shots {
      total: 0,
      per_game: 0.0,
      on_target: 0,
      on_target_per_game: 0.0,
      off_target: 0,
      off_target_per_game: 0.0,
      in_box: 0,
      in_box_per_game: 0.0,
      out_box: 0,
      out_box_per_game: 0.0,
      blocked: 0,
      blocked_per_game: 0.0,
    },
    passes: Passes {
      total: 0,
      per_game: 0.0,
      completed: 0,
      completed_per_game: 0.0,
      accuracy: 0.0,
    },
    xg: 0.0,
    possession: 0.0,
  }
}

struct Metrics {
  num_fixtures: Int,
  team: TeamMetrics,
  // this represents the combined metrics for opponents played
  against: TeamMetrics,
}

// i feel like "venue" isn't the best term for this
enum Venue {
  All,
  Home,
  Away
}

fn Venue::from_str(str: Str) Venue {
  match {
    str == "home" => Venue::Home,
    str == "away" => Venue::Away,
    _ => Venue::All
  }
}

fn get_metrics(db: sql::Database, team_id: Int, league_id: Int, season: Int, limit: Int?, venue: Venue) Metrics!Str {
  let entries = try fapi::get_team_played_fixtures(db, team_id: team_id, league_id: league_id, season: season, last: limit)

  mut fixture_stats_list: [fixtures::FixtureStats] = []
  for e, i in entries {
    let fixture_id = try decode::run(e, decode::path(["fixture", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let home_id = try decode::run(e, decode::path(["teams", "home", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

    // Filter by venue: only process if team played at the specified venue
    let is_home = home_id == team_id
    let should_process = match venue {
      Venue::All => true,
      Venue::Home => is_home,
      Venue::Away => not is_home
    }

    if should_process {
      // this is pretty ugly. to mitigate getting rate-limited, try to stagger requests
      if i > 9 { async::sleep(duration::from_seconds(1)) }

      let data = try fapi::get_fixture(db, fixture_id)
      let fs = try fixtures::decode_stats(data) -> errs { Result::err("Unable to decode fixture {fixture_id}: {decode::flatten(errs)}") }
      fixture_stats_list.push(fs)
    }
  }

  mut metrics = Metrics{
    num_fixtures: fixture_stats_list.size(),
    team: TeamMetrics::new(),
    against: TeamMetrics::new(),
  }

  for fs in fixture_stats_list {
    let is_home = fs.fixture.home.id == team_id

    let team_stats = match is_home {
      true => fs.home,
      false => fs.away
    }
    let opp_stats = match is_home {
      true => fs.away,
      false => fs.home
    }

    metrics.team.shots.total =+ team_stats.shots
    metrics.team.shots.blocked =+ team_stats.shots_blocked
    metrics.team.shots.on_target =+ team_stats.shots_on_goal
    metrics.team.shots.off_target =+ team_stats.shots - team_stats.shots_blocked - team_stats.shots_on_goal
    metrics.team.shots.in_box =+ team_stats.shots_in_box
    metrics.team.shots.out_box =+ team_stats.shots_out_box
    metrics.team.passes.total =+ team_stats.passes
    metrics.team.passes.completed =+ team_stats.passes_completed
    metrics.team.xg =+ team_stats.xg
    metrics.team.corners =+ team_stats.corners
    metrics.team.possession =+ team_stats.possession

    metrics.against.shots.total =+ opp_stats.shots
    metrics.against.shots.blocked =+ opp_stats.shots_blocked
    metrics.against.shots.on_target =+ opp_stats.shots_on_goal
    metrics.against.shots.off_target =+ opp_stats.shots - opp_stats.shots_blocked - opp_stats.shots_on_goal
    metrics.against.shots.in_box =+ opp_stats.shots_in_box
    metrics.against.shots.out_box =+ opp_stats.shots_out_box
    metrics.against.passes.total =+ opp_stats.passes
    metrics.against.passes.completed =+ opp_stats.passes_completed
    metrics.against.xg =+ opp_stats.xg
    metrics.against.corners =+ opp_stats.corners
    metrics.against.possession =+ opp_stats.possession
  }

  let num_games = Float::from_int(metrics.num_fixtures)

  metrics.team.shots.per_game = Float::from_int(metrics.team.shots.total) / num_games
  metrics.team.shots.on_target_per_game = Float::from_int(metrics.team.shots.on_target) / num_games
  metrics.team.shots.off_target_per_game = Float::from_int(metrics.team.shots.off_target) / num_games
  metrics.team.shots.in_box_per_game = Float::from_int(metrics.team.shots.in_box) / num_games
  metrics.team.shots.out_box_per_game = Float::from_int(metrics.team.shots.out_box) / num_games
  metrics.team.shots.blocked_per_game = Float::from_int(metrics.team.shots.blocked) / num_games

  metrics.against.shots.per_game = Float::from_int(metrics.against.shots.total) / num_games
  metrics.against.shots.on_target_per_game = Float::from_int(metrics.against.shots.on_target) / num_games
  metrics.against.shots.off_target_per_game = Float::from_int(metrics.against.shots.off_target) / num_games
  metrics.against.shots.in_box_per_game = Float::from_int(metrics.against.shots.in_box) / num_games
  metrics.against.shots.out_box_per_game = Float::from_int(metrics.against.shots.out_box) / num_games
  metrics.against.shots.blocked_per_game = Float::from_int(metrics.against.shots.blocked) / num_games

  // Passes per-game and accuracy
  metrics.team.passes.per_game = Float::from_int(metrics.team.passes.total) / num_games
  metrics.team.passes.completed_per_game = Float::from_int(metrics.team.passes.completed) / num_games
  metrics.team.passes.accuracy = Float::from_int(metrics.team.passes.completed) / Float::from_int(metrics.team.passes.total)

  metrics.against.passes.per_game = Float::from_int(metrics.against.passes.total) / num_games
  metrics.against.passes.completed_per_game = Float::from_int(metrics.against.passes.completed) / num_games
  metrics.against.passes.accuracy = Float::from_int(metrics.against.passes.completed) / Float::from_int(metrics.against.passes.total)

  // Possession average (possession is stored as 0.0-1.0 decimal)
  metrics.team.possession = metrics.team.possession / num_games
  metrics.against.possession = metrics.against.possession / num_games

  Result::ok(metrics)
}

// todo: this needs a better name
// todo: could this be merged with TeamMetrics struct?
struct Snapshot {
	num_games: Int,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,
	one_plus_scored: Int, // number of games in which team scored > 1 goal
	strike_rate: Float, // percentage of matches finding the net
	goals_diff: Int,
	xgf: Float,
	xga: Float,
	leakiness: Float,

	cleansheets: Int,
	one_conceded: Int,

	// could be presented as +1.5
	two_plus_conceded: Int,

	win_rate: Float,
}

impl Snapshot {
  fn to_dyn() Dynamic {
    Dynamic::object([
      "num_games": Dynamic::from(@num_games),
      "wins": Dynamic::from(@wins),
      "losses": Dynamic::from(@losses),
      "draws": Dynamic::from(@draws),
      "goals_against": Dynamic::from(@goals_against),
      "goals_for": Dynamic::from(@goals_for),
      "one_plus_scored": Dynamic::from(@one_plus_scored),
      "strike_rate": Dynamic::from(@strike_rate),
      "goals_diff": Dynamic::from(@goals_diff),
      "xgf": Dynamic::from(@xgf),
      "xga": Dynamic::from(@xga),
      "leakiness": Dynamic::from(@leakiness),
      "cleansheets": Dynamic::from(@cleansheets),
      "one_conceded": Dynamic::from(@one_conceded),
      "two_plus_conceded": Dynamic::from(@two_plus_conceded),
      "win_rate": Dynamic::from(@win_rate),
    ])
  }
}

// returns metrics over the last 5 games
// todo: this should support a timestamp or date so that it can provide form at that point
fn get_form(db: sql::Database, team_id: Int, league_id: Int, season: Int) Snapshot!Str {
  let entries = try fapi::get_team_played_fixtures(db, team_id: team_id, league_id: league_id, season: season, last: maybe::some(5))

  mut fixture_stats_list: [fixtures::FixtureStats] = []
  for e in entries {
    let fixture_id = try decode::run(e, decode::path(["fixture", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

    let data = try fapi::get_fixture(db, fixture_id)
    let fs = try fixtures::decode_stats(data) -> errs { Result::err(decode::flatten(errs)) }
    fixture_stats_list.push(fs)
  }

  mut wins = 0
  mut losses = 0
  mut draws = 0
  mut goals_for = 0
  mut goals_against = 0
  mut xg_for_total = 0.0
  mut xg_against_total = 0.0
  mut one_plus_scored = 0
  mut cleansheets = 0
  mut failed_to_score = 0
  mut at_least_1_against = 0
  mut two_plus_conceded = 0

  for fs in fixture_stats_list {
    let is_home = fs.fixture.home.id == team_id

    let team_stats = match is_home {
      true => fs.home,
      false => fs.away
    }
    let opp_stats = match is_home {
      true => fs.away,
      false => fs.home
    }

    let team_goals = match is_home {
      true => fs.fixture.home_goals,
      false => fs.fixture.away_goals
    }
    let opp_goals = match is_home {
      true => fs.fixture.away_goals,
      false => fs.fixture.home_goals
    }

    goals_for =+ team_goals
    goals_against =+ opp_goals
    xg_for_total =+ team_stats.xg
    xg_against_total =+ opp_stats.xg

    if team_goals == 0 { failed_to_score =+ 1 }
    if opp_goals == 0 { cleansheets =+ 1 }
    if team_goals > 1 { one_plus_scored =+ 1 }
    if opp_goals >= 1 { at_least_1_against =+ 1 }
    if opp_goals >= 2 { two_plus_conceded =+ 1 }

    match {
      team_goals > opp_goals => { wins =+ 1 },
      team_goals < opp_goals => { losses =+ 1 },
      _ => { draws =+ 1 }
    }
  }

  let num_games = fixture_stats_list.size()
  match num_games == 0 {
    true => Result::ok(Snapshot{
      num_games: 0,
      wins: 0,
      losses: 0,
      draws: 0,
      goals_against: 0,
      goals_for: 0,
      one_plus_scored: 0,
      strike_rate: 0.0,
      goals_diff: 0,
      xgf: 0.0,
      xga: 0.0,
      leakiness: 0.0,
      cleansheets: 0,
      one_conceded: 0,
      two_plus_conceded: 0,
      win_rate: 0.0,
    }),
    false => {
      let games = Float::from_int(num_games)
      let xgf = xg_for_total / games
      let xga = xg_against_total / games
      let one_conceded = at_least_1_against - two_plus_conceded

      Result::ok(Snapshot{
        num_games: num_games,
        wins: wins,
        losses: losses,
        draws: draws,
        goals_against: goals_against,
        goals_for: goals_for,
        one_plus_scored: one_plus_scored,
        strike_rate: 1.0 - Float::from_int(failed_to_score) / games,
        goals_diff: goals_for - goals_against,
        xgf: xgf,
        xga: xga,
        leakiness: Float::from_int(two_plus_conceded) / games * 100.0,
        cleansheets: cleansheets,
        one_conceded: one_conceded,
        two_plus_conceded: two_plus_conceded,
        win_rate: Float::from_int(wins) / games,
      })
    }
  }
}

// Constructs a Snapshot from raw counter values, computing derived stats like
// strike_rate, xgf/xga averages, leakiness, one_conceded, and win_rate.
// Returns an empty snapshot with zeroed values if games_counted is 0.
fn build_snapshot(
  games_counted: Int,
  wins: Int,
  losses: Int,
  draws: Int,
  goals_for: Int,
  goals_against: Int,
  xg_for_total: Float,
  xg_against_total: Float,
  one_plus_scored: Int,
  cleansheets: Int,
  failed_to_score: Int,
  at_least_1_against: Int,
  two_plus_conceded: Int
) Snapshot {
  match games_counted == 0 {
    true => Snapshot{
      num_games: 0,
      wins: 0,
      losses: 0,
      draws: 0,
      goals_against: 0,
      goals_for: 0,
      one_plus_scored: 0,
      strike_rate: 0.0,
      goals_diff: 0,
      xgf: 0.0,
      xga: 0.0,
      leakiness: 0.0,
      cleansheets: 0,
      one_conceded: 0,
      two_plus_conceded: 0,
      win_rate: 0.0,
    },
    false => {
      let games = Float::from_int(games_counted)
      let xgf = xg_for_total / games
      let xga = xg_against_total / games
      let one_conceded = at_least_1_against - two_plus_conceded

      Snapshot{
        num_games: games_counted,
        wins: wins,
        losses: losses,
        draws: draws,
        goals_against: goals_against,
        goals_for: goals_for,
        one_plus_scored: one_plus_scored,
        strike_rate: 1.0 - Float::from_int(failed_to_score) / games,
        goals_diff: goals_for - goals_against,
        xgf: xgf,
        xga: xga,
        leakiness: Float::from_int(two_plus_conceded) / games * 100.0,
        cleansheets: cleansheets,
        one_conceded: one_conceded,
        two_plus_conceded: two_plus_conceded,
        win_rate: Float::from_int(wins) / games,
      }
    }
  }
}

struct TeamSeasonStats {
  overall: Snapshot,
  home_only: Snapshot,
  away_only: Snapshot,
}

impl TeamSeasonStats {
  fn to_dyn() Dynamic {
    Dynamic::object([
      "overall": @overall.to_dyn(),
      "home_only": @home_only.to_dyn(),
      "away_only": @away_only.to_dyn(),
    ])
  }
}

// Computes stats split by home/away in a single pass
fn compute_season_stats(fixture_stats_list: [fixtures::FixtureStats], team_id: Int) TeamSeasonStats {
  // Overall counters
  mut all_wins = 0
  mut all_losses = 0
  mut all_draws = 0
  mut all_goals_for = 0
  mut all_goals_against = 0
  mut all_xg_for = 0.0
  mut all_xg_against = 0.0
  mut all_one_plus_scored = 0
  mut all_cleansheets = 0
  mut all_failed_to_score = 0
  mut all_at_least_1_against = 0
  mut all_two_plus_conceded = 0
  mut all_games = 0

  // Home-only counters
  mut home_wins = 0
  mut home_losses = 0
  mut home_draws = 0
  mut home_goals_for = 0
  mut home_goals_against = 0
  mut home_xg_for = 0.0
  mut home_xg_against = 0.0
  mut home_one_plus_scored = 0
  mut home_cleansheets = 0
  mut home_failed_to_score = 0
  mut home_at_least_1_against = 0
  mut home_two_plus_conceded = 0
  mut home_games = 0

  // Away-only counters
  mut away_wins = 0
  mut away_losses = 0
  mut away_draws = 0
  mut away_goals_for = 0
  mut away_goals_against = 0
  mut away_xg_for = 0.0
  mut away_xg_against = 0.0
  mut away_one_plus_scored = 0
  mut away_cleansheets = 0
  mut away_failed_to_score = 0
  mut away_at_least_1_against = 0
  mut away_two_plus_conceded = 0
  mut away_games = 0

  for fs in fixture_stats_list {
    let is_home = fs.fixture.home.id == team_id

    let team_stats = match is_home {
      true => fs.home,
      false => fs.away
    }
    let opp_stats = match is_home {
      true => fs.away,
      false => fs.home
    }
    let team_goals = match is_home {
      true => fs.fixture.home_goals,
      false => fs.fixture.away_goals
    }
    let opp_goals = match is_home {
      true => fs.fixture.away_goals,
      false => fs.fixture.home_goals
    }

    // Update overall
    all_games =+ 1
    all_goals_for =+ team_goals
    all_goals_against =+ opp_goals
    all_xg_for =+ team_stats.xg
    all_xg_against =+ opp_stats.xg
    if team_goals == 0 { all_failed_to_score =+ 1 }
    if opp_goals == 0 { all_cleansheets =+ 1 }
    if team_goals > 1 { all_one_plus_scored =+ 1 }
    if opp_goals >= 1 { all_at_least_1_against =+ 1 }
    if opp_goals >= 2 { all_two_plus_conceded =+ 1 }
    match {
      team_goals > opp_goals => { all_wins =+ 1 },
      team_goals < opp_goals => { all_losses =+ 1 },
      _ => { all_draws =+ 1 }
    }

    // Update home or away bucket
    match is_home {
      true => {
        home_games =+ 1
        home_goals_for =+ team_goals
        home_goals_against =+ opp_goals
        home_xg_for =+ team_stats.xg
        home_xg_against =+ opp_stats.xg
        if team_goals == 0 { home_failed_to_score =+ 1 }
        if opp_goals == 0 { home_cleansheets =+ 1 }
        if team_goals > 1 { home_one_plus_scored =+ 1 }
        if opp_goals >= 1 { home_at_least_1_against =+ 1 }
        if opp_goals >= 2 { home_two_plus_conceded =+ 1 }
        match {
          team_goals > opp_goals => { home_wins =+ 1 },
          team_goals < opp_goals => { home_losses =+ 1 },
          _ => { home_draws =+ 1 }
        }
      },
      false => {
        away_games =+ 1
        away_goals_for =+ team_goals
        away_goals_against =+ opp_goals
        away_xg_for =+ team_stats.xg
        away_xg_against =+ opp_stats.xg
        if team_goals == 0 { away_failed_to_score =+ 1 }
        if opp_goals == 0 { away_cleansheets =+ 1 }
        if team_goals > 1 { away_one_plus_scored =+ 1 }
        if opp_goals >= 1 { away_at_least_1_against =+ 1 }
        if opp_goals >= 2 { away_two_plus_conceded =+ 1 }
        match {
          team_goals > opp_goals => { away_wins =+ 1 },
          team_goals < opp_goals => { away_losses =+ 1 },
          _ => { away_draws =+ 1 }
        }
      }
    }
  }

  TeamSeasonStats{
    overall: build_snapshot(all_games, all_wins, all_losses, all_draws, all_goals_for, all_goals_against, all_xg_for, all_xg_against, all_one_plus_scored, all_cleansheets, all_failed_to_score, all_at_least_1_against, all_two_plus_conceded),
    home_only: build_snapshot(home_games, home_wins, home_losses, home_draws, home_goals_for, home_goals_against, home_xg_for, home_xg_against, home_one_plus_scored, home_cleansheets, home_failed_to_score, home_at_least_1_against, home_two_plus_conceded),
    away_only: build_snapshot(away_games, away_wins, away_losses, away_draws, away_goals_for, away_goals_against, away_xg_for, away_xg_against, away_one_plus_scored, away_cleansheets, away_failed_to_score, away_at_least_1_against, away_two_plus_conceded),
  }
}

// returns a team's stats across the whole season
fn get_team_season_stats(db: sql::Database, team_id: Int, league_id: Int, season: Int) TeamSeasonStats!Str {
  let entries = try fapi::get_team_played_fixtures(db, team_id: team_id, league_id: league_id, season: season, last: maybe::none())

  mut fixture_stats_list: [fixtures::FixtureStats] = []
  for e in entries {
    let fixture_id = try decode::run(e, decode::path(["fixture", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let data = try fapi::get_fixture(db, fixture_id)
    let fs = try fixtures::decode_stats(data) -> errs { Result::err(decode::flatten(errs)) }
    fixture_stats_list.push(fs)
  }

  Result::ok(compute_season_stats(fixture_stats_list, team_id))
}
