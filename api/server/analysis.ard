use ard/async
use ard/decode
use ard/duration
use ard/sql

use maestro/fapi
use maestro/fixtures
use maestro/leagues

struct Shots {
  total: Int
  per_game: Float,
  on_target: Int,
  on_target_per_game: Float,
  off_target: Int,
  off_target_per_game: Float,
  in_box: Int,
  in_box_per_game: Float,
  out_box: Int,
  out_box_per_game: Float,
  blocked: Int,
  blocked_per_game: Float,
}

struct TeamMetrics {
  corners: Int,
  shots: Shots,
  xg: Float,
}

fn TeamMetrics::new() TeamMetrics {
  TeamMetrics{
    corners: 0,
    shots: Shots {
      total: 0,
      per_game: 0.0,
      on_target: 0,
      on_target_per_game: 0.0,
      off_target: 0,
      off_target_per_game: 0.0,
      in_box: 0,
      in_box_per_game: 0.0,
      out_box: 0,
      out_box_per_game: 0.0,
      blocked: 0,
      blocked_per_game: 0.0,
    },
    xg: 0.0,
  }
}

struct Metrics {
  num_fixtures: Int,
  team: TeamMetrics,
  // this represents the combined metrics for opponents played
  against: TeamMetrics,
}

fn get_metrics_from_db(db: sql::Database, team_id: Int, league_id: Int, season: Int, limit: Int?) Metrics!Str {
  let base_query = "SELECT f.*, fs.* FROM fixtures f
    JOIN fixture_stats fs ON f.id = fs.fixture_id
    WHERE f.league_id = @league_id AND f.season = @season
    AND (f.home_id = @team_id OR f.away_id = @team_id)
    AND f.finished = true
    ORDER BY f.timestamp DESC"

  let query = match limit {
    n => "{base_query} LIMIT {n * 2}", // *2 because there are 2 rows per fixture
    _ => base_query
  }

  let fixture_stats = try db.query(query).all(["team_id": team_id, "season": season, "league_id": league_id])

  mut team = TeamMetrics::new()
  mut opp = TeamMetrics::new()

  for row in fixture_stats {
    let t_id = try decode::run(row, decode::field("team_id", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let total_shots = try decode::run(row, decode::field("shots", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let blocked_shots = try decode::run(row, decode::field("shots_blocked", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let shots_on_goal = try decode::run(row, decode::field("shots_on_goal", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let missed_shots = total_shots - blocked_shots - shots_on_goal

    let xg = try decode::run(row, decode::field("xg", decode::float)) -> errs { Result::err(errs.at(0).to_str()) }
    let corners = try decode::run(row, decode::field("corners", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

    match team_id == t_id {
      true => {
        team.shots.total =+ total_shots
        team.shots.blocked =+ blocked_shots
        team.shots.on_target =+ shots_on_goal
        team.shots.off_target =+ missed_shots
        team.shots.in_box =+ try decode::run(row, decode::field("shots_in_box", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
        team.shots.out_box =+ try decode::run(row, decode::field("shots_out_box", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

        team.xg =+ xg
        team.corners =+ corners
      },
      false => {
        opp.shots.total =+ total_shots
        opp.shots.blocked =+ blocked_shots
        opp.shots.on_target =+ shots_on_goal
        opp.shots.off_target =+ missed_shots
        opp.shots.in_box =+ try decode::run(row, decode::field("shots_in_box", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
        opp.shots.out_box =+ try decode::run(row, decode::field("shots_out_box", decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

        opp.xg =+ xg
        opp.corners =+ corners
      }
    }
  }

  // half because there are 2 rows per fixture (1 for each team)
  let num_games = Float::from_int(fixture_stats.size() / 2)

  team.shots.per_game = Float::from_int(team.shots.total) / num_games
  team.shots.on_target_per_game = Float::from_int(team.shots.on_target) / num_games
  team.shots.off_target_per_game = Float::from_int(team.shots.off_target) / num_games
  team.shots.in_box_per_game = Float::from_int(team.shots.in_box) / num_games
  team.shots.out_box_per_game = Float::from_int(team.shots.out_box) / num_games
  team.shots.blocked_per_game = Float::from_int(team.shots.blocked) / num_games

  opp.shots.per_game = Float::from_int(opp.shots.total) / num_games
  opp.shots.on_target_per_game = Float::from_int(opp.shots.on_target) / num_games
  opp.shots.off_target_per_game = Float::from_int(opp.shots.off_target) / num_games
  opp.shots.in_box_per_game = Float::from_int(opp.shots.in_box) / num_games
  opp.shots.out_box_per_game = Float::from_int(opp.shots.out_box) / num_games
  opp.shots.blocked_per_game = Float::from_int(opp.shots.blocked) / num_games

  Result::ok(Metrics{
    num_fixtures: num_games.to_int(),
    team: team,
    against: opp,
  })
}

fn get_metrics_from_api(db: sql::Database, team_id: Int, league_id: Int, season: Int, limit: Int?) Metrics!Str {
  let entries = try fapi::get_team_played_fixtures(db, team_id: team_id, league_id: league_id, season: season, last: limit)

  mut fixture_stats_list: [fixtures::FixtureStats] = []
  for e, i in entries {
    let fixture_id = try decode::run(e, decode::path(["fixture", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

    // this is pretty ugly. to mitigate getting rate-limited, try to stagger requests
    if i > 9 { async::sleep(duration::from_seconds(1)) }

    let data = try fapi::get_fixture(db, fixture_id)
    let fs = try fixtures::decode_stats(data) -> errs { Result::err("Unable to decode fixture {fixture_id}: {fixtures::collapse_errors("", errs)}") }
    fixture_stats_list.push(fs)
  }

  mut metrics = Metrics{
    num_fixtures: fixture_stats_list.size(),
    team: TeamMetrics::new(),
    against: TeamMetrics::new(),
  }

  for fs in fixture_stats_list {
    let is_home = fs.fixture.home.id == team_id

    let team_stats = match is_home {
      true => fs.home,
      false => fs.away
    }
    let opp_stats = match is_home {
      true => fs.away,
      false => fs.home
    }

    metrics.team.shots.total =+ team_stats.shots
    metrics.team.shots.blocked =+ team_stats.shots_blocked
    metrics.team.shots.on_target =+ team_stats.shots_on_goal
    metrics.team.shots.off_target =+ team_stats.shots - team_stats.shots_blocked - team_stats.shots_on_goal
    metrics.team.shots.in_box =+ team_stats.shots_in_box
    metrics.team.shots.out_box =+ team_stats.shots_out_box
    metrics.team.xg =+ team_stats.xg
    metrics.team.corners =+ team_stats.corners

    metrics.against.shots.total =+ opp_stats.shots
    metrics.against.shots.blocked =+ opp_stats.shots_blocked
    metrics.against.shots.on_target =+ opp_stats.shots_on_goal
    metrics.against.shots.off_target =+ opp_stats.shots - opp_stats.shots_blocked - opp_stats.shots_on_goal
    metrics.against.shots.in_box =+ opp_stats.shots_in_box
    metrics.against.shots.out_box =+ opp_stats.shots_out_box
    metrics.against.xg =+ opp_stats.xg
    metrics.against.corners =+ opp_stats.corners
  }

  let num_games = Float::from_int(metrics.num_fixtures)

  metrics.team.shots.per_game = Float::from_int(metrics.team.shots.total) / num_games
  metrics.team.shots.on_target_per_game = Float::from_int(metrics.team.shots.on_target) / num_games
  metrics.team.shots.off_target_per_game = Float::from_int(metrics.team.shots.off_target) / num_games
  metrics.team.shots.in_box_per_game = Float::from_int(metrics.team.shots.in_box) / num_games
  metrics.team.shots.out_box_per_game = Float::from_int(metrics.team.shots.out_box) / num_games
  metrics.team.shots.blocked_per_game = Float::from_int(metrics.team.shots.blocked) / num_games

  metrics.against.shots.per_game = Float::from_int(metrics.against.shots.total) / num_games
  metrics.against.shots.on_target_per_game = Float::from_int(metrics.against.shots.on_target) / num_games
  metrics.against.shots.off_target_per_game = Float::from_int(metrics.against.shots.off_target) / num_games
  metrics.against.shots.in_box_per_game = Float::from_int(metrics.against.shots.in_box) / num_games
  metrics.against.shots.out_box_per_game = Float::from_int(metrics.against.shots.out_box) / num_games
  metrics.against.shots.blocked_per_game = Float::from_int(metrics.against.shots.blocked) / num_games

  Result::ok(metrics)
}

fn get_metrics(db: sql::Database, team_id: Int, league_id: Int, season: Int, limit: Int?) Metrics!Str {
  match leagues::is_following(db, league_id) {
    true => get_metrics_from_db(db: db, team_id: team_id, league_id: league_id, season: season, limit: limit),
    false => get_metrics_from_api(db: db, team_id: team_id, league_id: league_id, season: season, limit: limit),
  }
}
