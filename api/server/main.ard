use ard/async
use ard/dates
use ard/decode
use ard/io
use ard/http
use ard/json
use ard/maybe

use maestro/analysis
use maestro/bets
use maestro/cache
use maestro/config
use maestro/db
use maestro/fixtures
use maestro/leagues
use maestro/predictions
use maestro/odds
use maestro/teams

let X_API_TOKEN = "X-Api-Token"

let res_headers = [
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, {X_API_TOKEN}",
  "Content-Type": "application/json"
]

fn internal_error(msg: Str) http::Response {
  mut headers = res_headers
  headers.drop("Content-Type")
  http::Response{
    status: 500,
    body: msg,
    headers: headers,
  }
}

fn unauthorized() http::Response {
  mut headers = res_headers
  headers.drop("Content-Type")
  http::Response{
    status: 403,
    headers: headers,
    body: "",
  }
}

fn empty_200() http::Response {
  http::Response{status: 200, headers: res_headers, body: ""}
}

fn no_content() http::Response {
  mut headers = res_headers
  headers.drop("Content-Type")
  http::Response{status: 204, headers: headers, body: ""}
}

mut nf_headers = res_headers
nf_headers.drop("Content-Type")
let not_found = http::Response{status:404, body:"Not found", headers:nf_headers}

fn main() {
  let conn = db::connect()

  let secret = config::api_key()
  fn is_authorized(header: Str?) Bool {
    match header {
      h => secret == h,
      _ => false
    }
  }

  if config::is_sync_enabled() {
    async::start(fn() { bets::update_outcomes(conn) })
    async::start(fn() { fixtures::sync(conn) })
  }

  async::start(cache::cleanup_job)

  let port = config::port()
  io::print("starting on port {port}")

  http::serve(
    port: port,
    handlers: [
      "/health": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let payload = Dynamic::object(["status": Dynamic::from("ok")])
            let body = try json::encode(payload) -> internal_error
            http::Response{status: 200, headers: res_headers, body: body}
          },
          _ => not_found
        }
      },

      "/bets": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let found_result = match Int::from_str(req.query_param("match_id")) {
              match_id => {
                let found = try bets::find_by_match(conn, match_id) -> internal_error
                struct Res { bets: [bets::Bet] }
                Res{bets: found}
              },
              _ => {
                let after = Int::from_str(req.query_param("after"))
                try bets::get_all_paged(conn, after) -> internal_error
              }
            }

            let body = try json::encode(found_result) -> internal_error
            http::Response{status: 200, headers: res_headers, body: body}
          },
          http::Method::Options => empty_200(),
          http::Method::Post => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              false => unauthorized(),
              true => {
                let raw_body = try decode::from_json(req.body.or("")) -> err { internal_error("Unable to parse request body: {err}") }
                let bet = try bets::create(conn, raw_body) -> internal_error
                let body = try json::encode(bet) -> internal_error
                http::Response{status: 200, headers: res_headers, body: body}
              },
            }
          },
          _ => not_found
        }
      },

      "/bets/:id": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Del => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              false => unauthorized(),
              true => {
                match Int::from_str(req.path_param("id")) {
                  id => {
                    try bets::delete(conn, id) -> internal_error
                    http::Response{status: 204, headers: res_headers, body: ""}
                  },
                  _ =>  not_found
                }
              }
            }
          },
          http::Method::Options => empty_200(),
          http::Method::Patch => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              false => unauthorized(),
              true => {
                match Int::from_str(req.path_param("id")) {
                  id => {
                    let raw_body = try decode::from_json(req.body.or("")) -> err { internal_error("Unable to parse request body: {err}") }
                    try bets::update(conn, id, raw_body) -> internal_error
                    no_content()
                  },
                  _ => not_found
                }
              },
            }
          },
          _ => not_found
        }
      },

      "/bets/overview": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let overview = try bets::get_overview(conn) -> internal_error

            match json::encode(overview) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
           _ => not_found
        }
      },

      "/leagues": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let data = try leagues::get_all(conn) -> internal_error

            struct Body { leagues: [leagues::League] }
            match json::encode(Body{ leagues: data }) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          http::Method::Post => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              true => {
                let body = try decode::from_json(req.body.or("")) -> internal_error
                // todo: not all failures are 500
                let input = try leagues::decode_follow_request(body) -> errs { internal_error(errs.at(0).to_str()) }
                try leagues::create(conn, input) -> internal_error
                no_content()
              },
              false => unauthorized()
            }
          },
          http::Method::Put => {
            match is_authorized(req.headers.get(X_API_TOKEN)) {
              true => {
                let body = try decode::from_json(req.body.or("")) -> internal_error
                // todo: not all failures are 500
                let id = try decode::run(body, decode::field("id", decode::int)) -> errs { internal_error(errs.at(0).to_str()) }
                let hidden = try decode::run(body, decode::field("hidden", decode::bool)) -> errs { internal_error(errs.at(0).to_str()) }
                try leagues::toggle_hidden(conn, id, hidden) -> internal_error
                no_content()
              },
              false => unauthorized()
            }
          },
           _ => not_found
        }
      },

      "/fixtures": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let date = req.query_param("date")
            let leagues = try leagues::get_active(conn) -> internal_error
            mut league_fixtures: [Str:Dynamic] = [:]

            for league in leagues {
              let fs = try fixtures::get_league_fixtures(
                db: conn,
                league_id: league.id,
                date: date
              ) -> internal_error

              if fs.size() > 0 {
                let list = Dynamic::list(fs, fn(f) { f.to_dynamic() })
                league_fixtures.set(league.id.to_str(), list)
              }
            }

            let body = try json::encode(league_fixtures) -> internal_error
            http::Response{status: 200, headers: res_headers, body: body}
          },
          _ => not_found
        }
      },

      "/fixtures/:id": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let id = try Int::from_str(req.path_param("id")) -> _ { not_found }
            let fixture = try fixtures::get(conn, id) -> internal_error

            match json::encode(fixture.to_dynamic()) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          _ => not_found
        }
      },

      "/fixtures/:id/odds": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let id = try Int::from_str(req.path_param("id")) -> _ { not_found }

            let data = try odds::get(conn, id) -> internal_error
            match json::encode(data) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          _ => not_found
        }
      },

      // Returns the recent completed fixtures for both teams in the fixture.
      // It defaults to the last 5.
      "/matchup/:fixture_id/form": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let fixture_id = try Int::from_str(req.path_param("fixture_id")) -> _ { not_found }
            let fixture = try fixtures::get(conn, fixture_id) -> internal_error

            let home_form = try fixtures::find_played(
              db: conn,
              team_id: fixture.home.id,
              league_id: fixture.league.id,
              season: fixture.season,
              count: 5
            ) -> internal_error
            let away_form = try fixtures::find_played(
              db: conn,
              team_id: fixture.away.id,
              league_id: fixture.league.id,
              season: fixture.season,
              count: 5
            ) -> internal_error

            let data = Dynamic::object([
              "home": Dynamic::list(home_form, fn (f) { f.to_dynamic() }),
              "away": Dynamic::list(away_form, fn (f) { f.to_dynamic() }),
            ])

            match json::encode(data) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          _ => not_found
        }
      },

      // Provide computed statistics for the teams coming into in the fixture.
      "/matchup/:fixture_id/stats": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let fixture_id = try Int::from_str(req.path_param("fixture_id")) -> _ { not_found }
            let fixture = try fixtures::get(conn, fixture_id) -> internal_error

            let home_season = try predictions::get_team_season_stats(
              db: conn,
              team_id: fixture.home.id,
              league_id: fixture.league.id,
              season: fixture.season
            ) -> internal_error

            let away_season = try predictions::get_team_season_stats(
              db: conn,
              team_id: fixture.away.id,
              league_id: fixture.league.id,
              season: fixture.season
            ) -> internal_error

            let form_data = match home_season.overall.num_games > 5 and away_season.overall.num_games > 5 {
              true => {
                let home_form = try analysis::get_form(
                  db: conn,
                  team_id: fixture.home.id,
                  league_id: fixture.league.id,
                  season: fixture.season
                ) -> internal_error
                let away_form = try analysis::get_form(
                  db: conn,
                  team_id: fixture.away.id,
                  league_id: fixture.league.id,
                  season: fixture.season
                ) -> internal_error

                Dynamic::object([
                  "home": home_form.to_dyn(),
                  "away": away_form.to_dyn(),
                ])
              },
              false => Dynamic::from(())
            }

            let data = Dynamic::object([
              "season": Dynamic::object([
                "home": home_season.to_dyn(),
                "away": away_season.to_dyn(),
              ]),
              "form": form_data,
            ])

            match json::encode(data) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          _ => not_found
        }
      },

      "/teams/:id": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let id = try Int::from_str(req.path_param("id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid team id", headers: headers}
            }
            let found = try teams::get(conn, id) -> internal_error
            let team = try found -> _ { not_found }
            match json::encode(team) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          _ => not_found
        }
      },

      "/teams/:id/metrics": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let team_id = try Int::from_str(req.path_param("id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid team id", headers: headers}
            }
            let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid league_id parameter", headers: headers}
            }
            let season = try Int::from_str(req.query_param("season")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid season parameter", headers: headers}
            }
            let limit = Int::from_str(req.query_param("limit"))
            let venue = analysis::Venue::from_str(req.query_param("venue"))

            let data = try analysis::get_metrics(db: conn, team_id: team_id, league_id: league_id, season: season, limit: limit, venue: venue) -> internal_error
            match json::encode(data) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          _ => not_found
        }
      },

      "/teams/:id/stats": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let team_id = try Int::from_str(req.path_param("id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid team id", headers: headers}
            }
            let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid league_id parameter", headers: headers}
            }
            let season = try Int::from_str(req.query_param("season")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid season parameter", headers: headers}
            }

            let season_stats = try predictions::get_team_season_stats(
              db: conn,
              team_id: team_id,
              league_id: league_id,
              season: season
            ) -> internal_error

            let form_data = match season_stats.overall.num_games > 5 {
              true => {
                let form = try analysis::get_form(
                  db: conn,
                  team_id: team_id,
                  league_id: league_id,
                  season: season
                ) -> internal_error
                form.to_dyn()
              },
              false => Dynamic::from(())
            }

            let data = Dynamic::object([
              "season": season_stats.to_dyn(),
              "form": form_data,
            ])

            match json::encode(data) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          _ => not_found
        }
      },

      "/teams/:id/fixtures": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let team_id = try Int::from_str(req.path_param("id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid team id", headers: headers}
            }
            let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid league_id parameter", headers: headers}
            }
            let season = try Int::from_str(req.query_param("season")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid season parameter", headers: headers}
            }

            let data = try fixtures::find(db: conn, team_id: team_id, league_id: league_id, season: season) -> internal_error
            let formatted = Dynamic::list(data, fn (f) { f.to_dynamic() })
            match json::encode(formatted) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          _ => not_found
        }
      },

      // overall performance data in a league (+ season)
      "/teams/:id/performance": fn(req: http::Request) http::Response {
        match req.method {
          http::Method::Get => {
            let team_id = try Int::from_str(req.path_param("id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid team id", headers: headers}
            }
            let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
              mut headers = res_headers
              headers.drop("Content-Type")
              http::Response{status: 400, body: "Invalid league_id parameter", headers: headers}
            }
            let season = Int::from_str(req.query_param("season")).or(config::CURRENT_SEASON)

            let maybe_league = try leagues::get(conn, league_id) -> internal_error
            let league = try maybe_league -> _ { not_found }

            let all_fixtures = try fixtures::find(db: conn, team_id: team_id, league_id: league_id, season: season) -> internal_error
            let played_fixtures = List::keep(all_fixtures, fn(f) { f.finished })
            mut played_home_fixture_count = 0
            mut played_away_fixture_count = 0
            mut wins_home = 0
            mut wins_away = 0
            mut draws_home = 0
            mut draws_away = 0
            mut losses_home = 0
            mut losses_away = 0
            mut goals_for_home = 0
            mut goals_for_away = 0
            mut goals_against_home = 0
            mut goals_against_away = 0
            mut cleansheets_home = 0
            mut cleansheets_away = 0
            mut failed_to_score_home = 0
            mut failed_to_score_away = 0

            for f in played_fixtures {
              match f.home.id == team_id {
                true => {
                  // is home team
                  played_home_fixture_count =+ 1
                  goals_for_home =+ f.home_goals
                  goals_against_home =+ f.away_goals
                  if f.home_goals == 0 { failed_to_score_home =+ 1 }
                  if f.away_goals == 0 { cleansheets_home =+ 1 }
                  match {
                    f.is_home_win() => { wins_home =+ 1 },
                    f.is_away_win() => { losses_home =+ 1 },
                    _ => { draws_home =+ 1 }
                  }
                },
                false => {
                  // is away team
                  played_away_fixture_count =+ 1
                  goals_for_away =+ f.away_goals
                  goals_against_away =+ f.home_goals
                  if f.away_goals == 0 { failed_to_score_away =+ 1 }
                  if f.home_goals == 0 { cleansheets_away =+ 1 }
                  match {
                    f.is_home_win() => { losses_away =+ 1 },
                    f.is_away_win() => { wins_away =+ 1 },
                    _ => { draws_away =+ 1 }
                  }
                }
              }
            }

            let data = Dynamic::object([
              "league": league.to_dyn(),
              "fixtures": Dynamic::object([
                "all": Dynamic::list(all_fixtures, fn (f: fixtures::Fixture) Dynamic {
                  f.to_dynamic()
                }),
                "played": Dynamic::object([
                  "home": Dynamic::from(played_home_fixture_count),
                  "away": Dynamic::from(played_away_fixture_count),
                  "total": Dynamic::from(played_home_fixture_count + played_away_fixture_count),
                ]),
                "wins": Dynamic::object([
                  "home": Dynamic::from(wins_home),
                  "away": Dynamic::from(wins_away),
                  "total": Dynamic::from(wins_home + wins_away),
                ]),
                "draws": Dynamic::object([
                  "home": Dynamic::from(draws_home),
                  "away": Dynamic::from(draws_away),
                  "total": Dynamic::from(draws_home + draws_away),
                ]),
                "losses": Dynamic::object([
                  "home": Dynamic::from(losses_home),
                  "away": Dynamic::from(losses_away),
                  "total": Dynamic::from(losses_home + losses_away),
                ]),
              ]),
              "goals": Dynamic::object([
                "for": Dynamic::object([
                  "home": Dynamic::from(goals_for_home),
                  "away": Dynamic::from(goals_for_away),
                  "total": Dynamic::from(goals_for_home + goals_for_away),
                ]),
                "against": Dynamic::object([
                  "home": Dynamic::from(goals_against_home),
                  "away": Dynamic::from(goals_against_away),
                  "total": Dynamic::from(goals_against_home + goals_against_away),
                ]),
              ]),
              "cleansheets": Dynamic::object([
                "home": Dynamic::from(cleansheets_home),
                "away": Dynamic::from(cleansheets_away),
                "total": Dynamic::from(cleansheets_home + cleansheets_away),
              ]),
              "failed_to_score": Dynamic::object([
                "home": Dynamic::from(failed_to_score_home),
                "away": Dynamic::from(failed_to_score_away),
                "total": Dynamic::from(failed_to_score_home + failed_to_score_away),
              ]),
            ])

            match json::encode(data) {
              ok(body) => http::Response{status:200, body:body, headers:res_headers},
              err => internal_error(err)
            }
          },
          http::Method::Options => empty_200(),
          _ => not_found
        }
      },
    ],
  )
}
