use ard/async
use ard/dates
use ard/decode
use ard/io
use ard/http
use ard/json
use ard/maybe

use maestro/analysis
use maestro/bets
use maestro/cache
use maestro/config
use maestro/db
use maestro/fapi
use maestro/fixtures
use maestro/leagues
use maestro/odds
use maestro/teams

let X_API_TOKEN = "X-Api-Token"

let BASE_HEADERS = [
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, {X_API_TOKEN}",
  "Content-Type": "application/json"
]

fn send_json(mut res: http::Response, data: Dynamic?, status: Int?) {
  res.headers = BASE_HEADERS

  match status {
    s => { res.status = s },
    _ => (),
  }

  let payload = data.or(Dynamic::from(()))
  match json::encode(payload) {
    ok(body) => { res.body = body },
    err => {
      res.status = 500
      res.body = err
    }
  }
}

fn unexpected_error(mut res: http::Response, msg: Str) {
  res.headers = BASE_HEADERS
  let payload = Dynamic::object(["error": Dynamic::from(msg)])
  send_json(res, payload, 500)
}

fn bad_inputs(mut res: http::Response, errors: [Str:Dynamic]) {
  res.headers = BASE_HEADERS
  send_json(res, Dynamic::object(errors), 400)
}

fn not_found(mut res: http::Response, msg: Str?) {
  res.headers = BASE_HEADERS

  let body = Dynamic::object(["error": Dynamic::from(msg.or("Not Found"))])
  send_json(res, body, 404)
}

fn unauthorized(mut res: http::Response) {
  res.headers = BASE_HEADERS
  let body = Dynamic::object(["error": Dynamic::from("Not authorized")])
  send_json(res, body, 403)
}

fn main() {
  let conn = db::connect()

  let secret = config::api_key()
  fn is_authorized(header: Str?) Bool {
    match header {
      h => secret == h,
      _ => false
    }
  }

  if config::is_sync_enabled() {
    async::start(fn() { bets::update_outcomes(conn) })
    async::start(fn() { fixtures::sync(conn) })
  }

  async::start(cache::cleanup_job)

  let port = config::port()
  io::print("starting on port {port}")

  http::serve(port, [
    "/health": fn(req: http::Request, mut res: http::Response) {
      send_json(res, Dynamic::object(["status": Dynamic::from("ok")]))
    },

    "/bets": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let data = match Int::from_str(req.query_param("match_id")) {
            match_id => {
              let found = try bets::find_by_match(conn, match_id) -> err { unexpected_error(res, err) }
              Dynamic::list(found, fn(b) { b.to_dyn() })
            },
            _ => {
              let after = Int::from_str(req.query_param("after"))
              let res = try bets::get_all_paged(conn, after) -> err { unexpected_error(res, err) }
              res.to_dyn()
            }
          }

          send_json(res, data)
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        http::Method::Post => {
          match is_authorized(req.headers.get(X_API_TOKEN)) {
            false => unauthorized(res),
            true => {
              let raw_body = try decode::from_json(req.body.or("")) -> err {
                bad_inputs(res, ["error": Dynamic::from(err)])
              }
              let bet = try bets::create(conn, raw_body) -> err { unexpected_error(res, err) }
              send_json(res, bet.to_dyn())
            },
          }
        },
        _ => not_found(res)
      }
    },

    "/bets/:id": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Del => {
          match is_authorized(req.headers.get(X_API_TOKEN)) {
            false => unauthorized(res),
            true => {
              match Int::from_str(req.path_param("id")) {
                id => {
                  try bets::delete(conn, id) -> err { unexpected_error(res, err) }
                  send_json(res, maybe::none(), 204)
                },
                _ => not_found(res)
              }
            }
          }
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        http::Method::Patch => {
          res.headers = BASE_HEADERS
          match is_authorized(req.headers.get(X_API_TOKEN)) {
            false => unauthorized(res),
            true => {
              match Int::from_str(req.path_param("id")) {
                id => {
                  let raw_body = try decode::from_json(req.body.or("")) -> err { bad_inputs(res, ["error": Dynamic::from(err)]) }
                  try bets::update(conn, id, raw_body) -> err { unexpected_error(res, err) }
                },
                _ => bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
              }
            },
          }
        },
        _ => not_found(res)
      }
    },

    "/bets/overview": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let overview = try bets::get_overview(conn) -> err { unexpected_error(res, err) }

          send_json(res, overview.to_dyn())
        },
         _ => not_found(res)
      }
    },

    "/leagues": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let leagues = try leagues::get_all(conn) -> err { unexpected_error(res, err) }
          send_json(res, Dynamic::list(leagues, fn(l) { l.to_dyn() }))
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        http::Method::Post => {
          match is_authorized(req.headers.get(X_API_TOKEN)) {
            true => {
              let body = try decode::from_json(req.body.or("")) -> err {
                bad_inputs(res, ["error": Dynamic::from(err)])
              }
              let input = try leagues::decode_follow_request(body) -> errs {
                bad_inputs(res, ["error": Dynamic::from(decode::flatten(errs))])
              }
              try leagues::create(conn, input) -> err { unexpected_error(res, err) }
            },
            false => unauthorized(res)
          }
        },
        http::Method::Put => {
          match is_authorized(req.headers.get(X_API_TOKEN)) {
            true => {
              let body = try decode::from_json(req.body.or("")) -> err {
                bad_inputs(res, ["error": Dynamic::from(err)])
              }
              let id = try decode::run(body, decode::field("id", decode::int)) -> errs {
                bad_inputs(res, ["id": Dynamic::from(errs.at(0).to_str())])
              }
              let hidden = try decode::run(body, decode::field("hidden", decode::nullable(decode::bool))) -> errs {
                bad_inputs(res, ["hidden": Dynamic::from(errs.at(0).to_str())])
              }
              try leagues::toggle_hidden(conn, id, hidden.or(false)) -> err {
                unexpected_error(res, err)
              }
            },
            false => unauthorized(res)
          }
        },
         _ => not_found(res)
      }
    },

    "/fixtures": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let date = req.query_param("date")
          let leagues = try leagues::get_active(conn) -> err {
            unexpected_error(res, err)
          }
          mut league_fixtures: [Str:Dynamic] = [:]

          for league in leagues {
            let fs = try fixtures::get_league_fixtures(
              db: conn,
              league_id: league.id,
              date: date
            ) -> err { unexpected_error(res, err) }

            if fs.size() > 0 {
              let list = Dynamic::list(fs, fn(f) { f.to_dynamic() })
              league_fixtures.set(league.id.to_str(), list)
            }
          }

          send_json(res, Dynamic::object(league_fixtures))
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        _ => not_found(res)
      }
    },

    "/fixtures/:id": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let fixture = try fixtures::get(conn, id) -> err { unexpected_error(res, err) }

          send_json(res, fixture.to_dynamic())
        },
        _ => not_found(res)
      }
    },

    // return stats from the game
    "/fixtures/:id/stats": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let fixture_stats = try fixtures::get_stats(conn, id) -> err { unexpected_error(res, err) }

          send_json(res, fixture_stats.to_dyn())
        },
        _ => not_found(res)
      }
    },

    "/fixtures/:id/odds": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }

          let data = try odds::get(conn, id) -> err { unexpected_error(res, err) }
          let data = Dynamic::list(data, fn(stat) { stat.to_dyn() })
          send_json(res, data)
        },
        _ => not_found(res)
      }
    },

    // Returns the recent completed fixtures for both teams in the fixture.
    // It defaults to the last 5.
    "/matchup/:fixture_id/form": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let fixture_id = try Int::from_str(req.path_param("fixture_id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let fixture = try fixtures::get(conn, fixture_id) -> err { unexpected_error(res, err) }

          let home_form = try fixtures::find_played(
            db: conn,
            team_id: fixture.home.id,
            league_id: fixture.league.id,
            season: fixture.season,
            count: 5
          ) -> err { unexpected_error(res, err) }
          let away_form = try fixtures::find_played(
            db: conn,
            team_id: fixture.away.id,
            league_id: fixture.league.id,
            season: fixture.season,
            count: 5
          ) -> err { unexpected_error(res, err) }

          let data = Dynamic::object([
            "home": Dynamic::list(home_form, fn (f) { f.to_dynamic() }),
            "away": Dynamic::list(away_form, fn (f) { f.to_dynamic() }),
          ])

          send_json(res, data)
        },
        _ => not_found(res)
      }
    },

    // Provide computed statistics for the teams coming into in the fixture.
    "/matchup/:fixture_id/stats": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let fixture_id = try Int::from_str(req.path_param("fixture_id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let fixture = try fixtures::get(conn, fixture_id) -> err { unexpected_error(res, err) }

          let home_season = try analysis::get_team_season_stats(
            db: conn,
            team_id: fixture.home.id,
            league_id: fixture.league.id,
            season: fixture.season
          ) -> err { unexpected_error(res, err) }

          let away_season = try analysis::get_team_season_stats(
            db: conn,
            team_id: fixture.away.id,
            league_id: fixture.league.id,
            season: fixture.season
          ) -> err { unexpected_error(res, err) }

          let form_data = match home_season.overall.num_games > 5 and away_season.overall.num_games > 5 {
            true => {
              let home_form = try analysis::get_form(
                db: conn,
                team_id: fixture.home.id,
                league_id: fixture.league.id,
                season: fixture.season
              ) -> err { unexpected_error(res, err) }
              let away_form = try analysis::get_form(
                db: conn,
                team_id: fixture.away.id,
                league_id: fixture.league.id,
                season: fixture.season
              ) -> err { unexpected_error(res, err) }

              Dynamic::object([
                "home": home_form.to_dyn(),
                "away": away_form.to_dyn(),
              ])
            },
            false => Dynamic::from(())
          }

          let data = Dynamic::object([
            "season": Dynamic::object([
              "home": home_season.to_dyn(),
              "away": away_season.to_dyn(),
            ]),
            "form": form_data,
          ])

          send_json(res, data)
        },
        _ => not_found(res)
      }
    },

    "/teams/:id": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let found = try teams::get(conn, id) -> err { unexpected_error(res, err) }
          let team = try found -> _ { not_found(res) }
          send_json(res, team.to_dyn())
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        _ => not_found(res)
      }
    },

    "/teams/:id/metrics": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let team_id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid league id")])
          }
          let season = try Int::from_str(req.query_param("season")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid season")])
          }
          let limit = Int::from_str(req.query_param("limit"))
          let venue = analysis::Venue::from_str(req.query_param("venue"))

          let data = try analysis::get_metrics(
            db: conn,
            team_id: team_id,
            league_id: league_id,
            season: season,
            limit: limit,
            venue: venue
          ) -> err {
            unexpected_error(res, err)
          }

          res.headers = BASE_HEADERS
          match json::encode(data) {
            ok(body) => { res.body = body },
            err => { unexpected_error(res, err) }
          }
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        _ => not_found(res)
      }
    },

    "/teams/:id/stats": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let team_id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid league id")])
          }
          let season = try Int::from_str(req.query_param("season")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid season")])
          }

          let season_stats = try analysis::get_team_season_stats(
            db: conn,
            team_id: team_id,
            league_id: league_id,
            season: season
          ) -> err { unexpected_error(res, err) }

          let form_data = match season_stats.overall.num_games > 5 {
            true => {
              let form = try analysis::get_form(
                db: conn,
                team_id: team_id,
                league_id: league_id,
                season: season
              ) -> err { unexpected_error(res, err) }
              form.to_dyn()
            },
            false => Dynamic::from(())
          }

          let data = Dynamic::object([
            "season": season_stats.to_dyn(),
            "form": form_data,
          ])

          send_json(res, data)
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        _ => not_found(res)
      }
    },

    "/teams/:id/fixtures": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let team_id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid league id")])
          }
          let season = try Int::from_str(req.query_param("season")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid season")])
          }

          let data = try fixtures::find(db: conn, team_id: team_id, league_id: league_id, season: season) -> err { unexpected_error(res, err) }
          let formatted = Dynamic::list(data, fn (f) { f.to_dynamic() })
          send_json(res, formatted)
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        _ => not_found(res)
      }
    },

    // overall performance data in a league (+ season)
    "/teams/:id/performance": fn(req: http::Request, mut res: http::Response) {
      match req.method {
        http::Method::Get => {
          let team_id = try Int::from_str(req.path_param("id")) -> _ {
            bad_inputs(res, ["id": Dynamic::from("Invalid ID")])
          }
          let league_id = try Int::from_str(req.query_param("league_id")) -> _ {
            bad_inputs(res, ["league_id": Dynamic::from("Invalid league id")])
          }
          let season = match Int::from_str(req.query_param("season")) {
             s => s,
             _ => try fapi::get_league_current_season(conn, league_id) -> err { unexpected_error(res, err) }
          }
          let maybe_league = try leagues::get(conn, league_id) -> err { unexpected_error(res, err) }
          let league = try maybe_league -> _ {
            bad_inputs(res, ["league_id": Dynamic::from("League not found")])
          }

          let all_fixtures = try fixtures::find(db: conn, team_id: team_id, league_id: league_id, season: season) -> err { unexpected_error(res, err) }
          let played_fixtures = List::keep(all_fixtures, fn(f) { f.finished })
          mut played_home_fixture_count = 0
          mut played_away_fixture_count = 0
          mut wins_home = 0
          mut wins_away = 0
          mut draws_home = 0
          mut draws_away = 0
          mut losses_home = 0
          mut losses_away = 0
          mut goals_for_home = 0
          mut goals_for_away = 0
          mut goals_against_home = 0
          mut goals_against_away = 0
          mut cleansheets_home = 0
          mut cleansheets_away = 0
          mut failed_to_score_home = 0
          mut failed_to_score_away = 0

          for f in played_fixtures {
            match f.home.id == team_id {
              true => {
                // is home team
                played_home_fixture_count =+ 1
                goals_for_home =+ f.home_goals
                goals_against_home =+ f.away_goals
                if f.home_goals == 0 { failed_to_score_home =+ 1 }
                if f.away_goals == 0 { cleansheets_home =+ 1 }
                match {
                  f.is_home_win() => { wins_home =+ 1 },
                  f.is_away_win() => { losses_home =+ 1 },
                  _ => { draws_home =+ 1 }
                }
              },
              false => {
                // is away team
                played_away_fixture_count =+ 1
                goals_for_away =+ f.away_goals
                goals_against_away =+ f.home_goals
                if f.away_goals == 0 { failed_to_score_away =+ 1 }
                if f.home_goals == 0 { cleansheets_away =+ 1 }
                match {
                  f.is_home_win() => { losses_away =+ 1 },
                  f.is_away_win() => { wins_away =+ 1 },
                  _ => { draws_away =+ 1 }
                }
              }
            }
          }

          let data = Dynamic::object([
            "league": league.to_dyn(),
            "fixtures": Dynamic::object([
              "all": Dynamic::list(all_fixtures, fn (f: fixtures::Fixture) Dynamic {
                f.to_dynamic()
              }),
              "played": Dynamic::object([
                "home": Dynamic::from(played_home_fixture_count),
                "away": Dynamic::from(played_away_fixture_count),
                "total": Dynamic::from(played_home_fixture_count + played_away_fixture_count),
              ]),
              "wins": Dynamic::object([
                "home": Dynamic::from(wins_home),
                "away": Dynamic::from(wins_away),
                "total": Dynamic::from(wins_home + wins_away),
              ]),
              "draws": Dynamic::object([
                "home": Dynamic::from(draws_home),
                "away": Dynamic::from(draws_away),
                "total": Dynamic::from(draws_home + draws_away),
              ]),
              "losses": Dynamic::object([
                "home": Dynamic::from(losses_home),
                "away": Dynamic::from(losses_away),
                "total": Dynamic::from(losses_home + losses_away),
              ]),
            ]),
            "goals": Dynamic::object([
              "for": Dynamic::object([
                "home": Dynamic::from(goals_for_home),
                "away": Dynamic::from(goals_for_away),
                "total": Dynamic::from(goals_for_home + goals_for_away),
              ]),
              "against": Dynamic::object([
                "home": Dynamic::from(goals_against_home),
                "away": Dynamic::from(goals_against_away),
                "total": Dynamic::from(goals_against_home + goals_against_away),
              ]),
            ]),
            "cleansheets": Dynamic::object([
              "home": Dynamic::from(cleansheets_home),
              "away": Dynamic::from(cleansheets_away),
              "total": Dynamic::from(cleansheets_home + cleansheets_away),
            ]),
            "failed_to_score": Dynamic::object([
              "home": Dynamic::from(failed_to_score_home),
              "away": Dynamic::from(failed_to_score_away),
              "total": Dynamic::from(failed_to_score_home + failed_to_score_away),
            ]),
          ])

          send_json(res, data)
        },
        http::Method::Options => { res.headers = BASE_HEADERS },
        _ => not_found(res)
      }
    },
  ])
}
