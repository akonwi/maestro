use ard/async
use ard/chrono
use ard/decode
use ard/duration
use ard/io
use ard/json
use ard/maybe
use ard/sql

use maestro/db as _db

// TTL constants in seconds
let TTL_ODDS = 14400               // 4 hours
let TTL_FIXTURE = 7200             // 2 hours
let TTL_TEAM_FIXTURES = 21600      // 6 hours
let TTL_TODAY_FIXTURES = 900       // 15 minutes
let TTL_SEASON_FIXTURES = 21600    // 6 hours
let TTL_LEAGUE = 14400             // 4 hours
let TTL_TEAM = 86400               // 24 hours
let TTL_TEAM_PLAYED = 21600        // 6 hours
let TTL_CURRENT_SEASON = 86400 * 2 // 48 hours

// Get cached response if it exists and hasn't expired
// Returns none if not cached, expired, or on any error (cache miss)
fn get(db: sql::Database, endpoint: Str) Dynamic? {
  let now = chrono::now()

  let row = try db.query(
    "SELECT response FROM api_cache WHERE endpoint = @endpoint AND expires_at > @now"
  ).first(["endpoint": endpoint, "now": now]) -> err {
    io::print("[CACHE] Failed to read cache ({endpoint}): {err}")
    maybe::none()
  }

  match row {
    r => {
      let response_str = try decode::run(r, decode::field("response", decode::string)) -> _ {
        io::print("[CACHE] Failed to decode response from cache")
        maybe::none()
      }

      let response = try decode::from_json(response_str) -> _ {
        io::print("[CACHE] Failed to parse cached JSON")
        maybe::none()
      }

      maybe::some(response)
    },
    _ => maybe::none()
  }
}

fn get_ttl(endpoint: Str) Int {
  match {
    endpoint.starts_with("odds") => TTL_ODDS,
    endpoint.starts_with("leagues") => TTL_LEAGUE,
    endpoint.starts_with("teams") => TTL_TEAM,
    endpoint.starts_with("fixtures?id") => TTL_FIXTURE,
    endpoint.contains("date=") => TTL_TODAY_FIXTURES,
    endpoint.contains("status=FT") => TTL_TEAM_PLAYED,
    _ => TTL_TEAM_FIXTURES,
  }
}

// Set cache entry
fn set(db: sql::Database, endpoint: Str, response: Dynamic, ttl: Int?) Void!Str {
  let now = chrono::now()
  let ttl_seconds = ttl.or(get_ttl(endpoint))
  let expires_at = now + ttl_seconds
  let response_str = try json::encode(response) -> err {
    let msg = "Failed to encode response to JSON for cache: {err}"
    io::print(msg)
    Result::err(msg)
  }

  let sql = "INSERT INTO api_cache (endpoint, response, ttl_seconds, created_at, expires_at)
             VALUES (@endpoint, @response, @ttl_seconds, @created_at, @expires_at)
             ON CONFLICT(endpoint) DO UPDATE SET response = @response, created_at = @created_at, expires_at = @expires_at"

  try db.query(sql).run([
    "endpoint": endpoint,
    "response": response_str,
    "ttl_seconds": ttl_seconds,
    "created_at": now,
    "expires_at": expires_at
  ]) -> err {
    let msg = "Failed to cache response: {err}"
    io::print(msg)
    Result::err(msg)
  }

  Result::ok(())
}

fn get_or_set(db: sql::Database, endpoint: Str, create: fn(Str) Dynamic!Str, ttl: Int?) Dynamic!Str {
  match get(db, endpoint) {
    data => Result::ok(data),
    _ => {
      let data = try create(endpoint)
      set(db, endpoint, data)
      Result::ok(data)
    }
  }
}

// Clean up expired cache entries
fn cleanup_job() {
  while {
    let db = _db::connect()
    match db.query("DELETE FROM api_cache WHERE expires_at <= @now").run(["now": chrono::now()]) {
      ok => io::print("Cleaned up expired cache data"),
      err => io::print("Failed to clean up expired cache entries: {err}")
    }
    db.close()
    async::sleep(duration::from_hours(1))
  }
}
