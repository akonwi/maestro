use ard/decode
use ard/io
use ard/sql

use maestro/fixtures
use maestro/leagues
use maestro/odds
use maestro/predictions

struct BetResult {
  fixture_id: Int,
  bet_type: Int,
  pick_name: Str,
  pick_odd: Int,
  ev_percentage: Float,
  actual_outcome: Str,
  payout: Float,
}

struct BetTypeStats {
  bet_type: Int,
  name: Str,
  picks: Int,
  wins: Int,
  losses: Int,
  win_rate: Float,
  roi: Float,
  avg_ev: Float,
}

struct BacktestResult {
  season: Int,
  fixtures_tested: Int,
  fixtures_skipped: Int,
  total_picks: Int,
  by_bet_type: [BetTypeStats],
  overall_win_rate: Float,
  overall_roi: Float,
}

struct FormResult {
  snapshot: predictions::Snapshot,
  ok: Bool,
}

fn empty_form_result() FormResult {
  FormResult{
    snapshot: predictions::build_snapshot(0, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0, 0, 0, 0),
    ok: false,
  }
}

struct FormRowData {
  home_id: Int,
  home_goals: Int,
  away_goals: Int,
  team_xg: Float,
  opp_xg: Float,
  valid: Bool,
}

fn decode_form_row(row: Dynamic) FormRowData {
  let home_id = try decode::run(row, decode::field("home_id", decode::int)) -> _ {
    FormRowData{ home_id: 0, home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let home_goals = try decode::run(row, decode::field("home_goals", decode::int)) -> _ {
    FormRowData{ home_id: 0, home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let away_goals = try decode::run(row, decode::field("away_goals", decode::int)) -> _ {
    FormRowData{ home_id: 0, home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let team_xg = try decode::run(row, decode::field("team_xg", decode::float)) -> _ {
    FormRowData{ home_id: 0, home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let opp_xg = try decode::run(row, decode::field("opp_xg", decode::float)) -> _ {
    FormRowData{ home_id: 0, home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }

  FormRowData{
    home_id: home_id,
    home_goals: home_goals,
    away_goals: away_goals,
    team_xg: team_xg,
    opp_xg: opp_xg,
    valid: true,
  }
}

fn normalize_timestamp(ts: Int) Int {
  match ts >= 10000000000 {
    true => ts / 1000,
    false => ts
  }
}

fn get_form_as_of(db: sql::Database, team_id: Int, league_id: Int, season: Int, before_timestamp: Int) FormResult {
  let ts = normalize_timestamp(before_timestamp)
  // Use string interpolation for team_id in JOINs since params in JOIN clauses may not work
  let rows = try db.query("
    SELECT
      f.id,
      f.home_id,
      f.away_id,
      f.home_goals,
      f.away_goals,
      fs_team.xg as team_xg,
      fs_opp.xg as opp_xg
    FROM fixtures f
    INNER JOIN fixture_stats fs_team ON fs_team.fixture_id = f.id AND fs_team.team_id = {team_id}
    INNER JOIN fixture_stats fs_opp ON fs_opp.fixture_id = f.id AND fs_opp.team_id != {team_id}
    WHERE (f.home_id = {team_id} OR f.away_id = {team_id})
      AND f.league_id = @league_id
      AND f.season = @season
      AND f.finished = 1
      AND (CASE WHEN f.timestamp >= 10000000000 THEN f.timestamp / 1000 ELSE f.timestamp END) < @before_timestamp
    ORDER BY f.timestamp DESC
    LIMIT 5
  ").all([
    "league_id": league_id,
    "season": season,
    "before_timestamp": ts
  ]) -> _ {
    empty_form_result()
  }

  match rows.size() < 5 {
    true => empty_form_result(),
    false => {
      mut wins = 0
      mut losses = 0
      mut draws = 0
      mut goals_for = 0
      mut goals_against = 0
      mut xg_for_total = 0.0
      mut xg_against_total = 0.0
      mut one_plus_scored = 0
      mut cleansheets = 0
      mut failed_to_score = 0
      mut at_least_1_against = 0
      mut two_plus_conceded = 0
      mut valid_rows = 0

      for row in rows {
        let data = decode_form_row(row)
        if data.valid {
          let is_home = data.home_id == team_id
          let team_goals = match is_home {
            true => data.home_goals,
            false => data.away_goals
          }
          let opp_goals = match is_home {
            true => data.away_goals,
            false => data.home_goals
          }

          goals_for =+ team_goals
          goals_against =+ opp_goals
          xg_for_total =+ data.team_xg
          xg_against_total =+ data.opp_xg

          if team_goals == 0 { failed_to_score =+ 1 }
          if opp_goals == 0 { cleansheets =+ 1 }
          if team_goals > 1 { one_plus_scored =+ 1 }
          if opp_goals >= 1 { at_least_1_against =+ 1 }
          if opp_goals >= 2 { two_plus_conceded =+ 1 }

          match {
            team_goals > opp_goals => { wins =+ 1 },
            team_goals < opp_goals => { losses =+ 1 },
            _ => { draws =+ 1 }
          }
          valid_rows =+ 1
        }
      }

      match valid_rows >= 5 {
        false => empty_form_result(),
        true => FormResult{
          snapshot: predictions::build_snapshot(
            valid_rows,
            wins,
            losses,
            draws,
            goals_for,
            goals_against,
            xg_for_total,
            xg_against_total,
            one_plus_scored,
            cleansheets,
            failed_to_score,
            at_least_1_against,
            two_plus_conceded
          ),
          ok: true,
        }
      }
    }
  }
}

struct VenueRowData {
  home_goals: Int,
  away_goals: Int,
  team_xg: Float,
  opp_xg: Float,
  valid: Bool,
}

fn decode_venue_row(row: Dynamic) VenueRowData {
  let home_goals = try decode::run(row, decode::field("home_goals", decode::int)) -> _ {
    VenueRowData{ home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let away_goals = try decode::run(row, decode::field("away_goals", decode::int)) -> _ {
    VenueRowData{ home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let team_xg = try decode::run(row, decode::field("team_xg", decode::float)) -> _ {
    VenueRowData{ home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }
  let opp_xg = try decode::run(row, decode::field("opp_xg", decode::float)) -> _ {
    VenueRowData{ home_goals: 0, away_goals: 0, team_xg: 0.0, opp_xg: 0.0, valid: false }
  }

  VenueRowData{
    home_goals: home_goals,
    away_goals: away_goals,
    team_xg: team_xg,
    opp_xg: opp_xg,
    valid: true,
  }
}

fn get_venue_stats_as_of(db: sql::Database, team_id: Int, league_id: Int, season: Int, is_home: Bool, before_timestamp: Int) FormResult {
  let venue_filter = match is_home {
    true => "f.home_id = {team_id}",
    false => "f.away_id = {team_id}"
  }
  let ts = normalize_timestamp(before_timestamp)

  let rows = try db.query("
    SELECT
      f.id,
      f.home_id,
      f.away_id,
      f.home_goals,
      f.away_goals,
      fs_team.xg as team_xg,
      fs_opp.xg as opp_xg
    FROM fixtures f
    INNER JOIN fixture_stats fs_team ON fs_team.fixture_id = f.id AND fs_team.team_id = {team_id}
    INNER JOIN fixture_stats fs_opp ON fs_opp.fixture_id = f.id AND fs_opp.team_id != {team_id}
    WHERE {venue_filter}
      AND f.league_id = @league_id
      AND f.season = @season
      AND f.finished = 1
      AND (CASE WHEN f.timestamp >= 10000000000 THEN f.timestamp / 1000 ELSE f.timestamp END) < @before_timestamp
    ORDER BY f.timestamp DESC
  ").all([
    "league_id": league_id,
    "season": season,
    "before_timestamp": ts
  ]) -> _ {
    empty_form_result()
  }

  match rows.size() == 0 {
    true => empty_form_result(),
    false => {
      mut wins = 0
      mut losses = 0
      mut draws = 0
      mut goals_for = 0
      mut goals_against = 0
      mut xg_for_total = 0.0
      mut xg_against_total = 0.0
      mut one_plus_scored = 0
      mut cleansheets = 0
      mut failed_to_score = 0
      mut at_least_1_against = 0
      mut two_plus_conceded = 0
      mut valid_rows = 0

      for row in rows {
        let data = decode_venue_row(row)
        if data.valid {
          let team_goals = match is_home {
            true => data.home_goals,
            false => data.away_goals
          }
          let opp_goals = match is_home {
            true => data.away_goals,
            false => data.home_goals
          }

          goals_for =+ team_goals
          goals_against =+ opp_goals
          xg_for_total =+ data.team_xg
          xg_against_total =+ data.opp_xg

          if team_goals == 0 { failed_to_score =+ 1 }
          if opp_goals == 0 { cleansheets =+ 1 }
          if team_goals > 1 { one_plus_scored =+ 1 }
          if opp_goals >= 1 { at_least_1_against =+ 1 }
          if opp_goals >= 2 { two_plus_conceded =+ 1 }

          match {
            team_goals > opp_goals => { wins =+ 1 },
            team_goals < opp_goals => { losses =+ 1 },
            _ => { draws =+ 1 }
          }
          valid_rows =+ 1
        }
      }

      match valid_rows > 0 {
        false => empty_form_result(),
        true => FormResult{
          snapshot: predictions::build_snapshot(
            valid_rows,
            wins,
            losses,
            draws,
            goals_for,
            goals_against,
            xg_for_total,
            xg_against_total,
            one_plus_scored,
            cleansheets,
            failed_to_score,
            at_least_1_against,
            two_plus_conceded
          ),
          ok: true,
        }
      }
    }
  }
}

fn resolve_outcome(pick: Str, fixture: fixtures::Fixture) Str {
  match {
    pick == "Home" and fixture.is_home_win() => "win",
    pick == "Away" and fixture.is_away_win() => "win",
    pick == "Draw" and fixture.home_goals == fixture.away_goals => "win",
    _ => "lose"
  }
}

fn parse_line(pick: Str) Float {
  match {
    pick.contains("6.5") => 6.5,
    pick.contains("5.5") => 5.5,
    pick.contains("4.5") => 4.5,
    pick.contains("3.5") => 3.5,
    pick.contains("2.5") => 2.5,
    pick.contains("1.5") => 1.5,
    pick.contains("0.5") => 0.5,
    _ => 0.0
  }
}

fn resolve_goals(pick: Str, goals: Int) Str {
  let line = parse_line(pick)
  let is_over = pick.starts_with("Over")
  let goals_float = Float::from_int(goals)
  match is_over {
    true => match goals_float > line {
      true => "win",
      false => "lose"
    },
    false => match goals_float < line {
      true => "win",
      false => "lose"
    }
  }
}

fn resolve_cleansheet(pick: Str, opp_goals: Int) Str {
  match {
    pick == "Yes" and opp_goals == 0 => "win",
    pick == "No" and opp_goals > 0 => "win",
    _ => "lose"
  }
}

fn resolve_bet(bet_type: Int, pick_name: Str, fixture: fixtures::Fixture) Str {
  match bet_type {
    1 => resolve_outcome(pick_name, fixture),
    16 => resolve_goals(pick_name, fixture.home_goals),
    17 => resolve_goals(pick_name, fixture.away_goals),
    27 => resolve_cleansheet(pick_name, fixture.away_goals),
    28 => resolve_cleansheet(pick_name, fixture.home_goals),
    _ => "lose"
  }
}

fn calculate_payout(american_odds: Int, outcome: Str) Float {
  match outcome == "win" {
    true => match american_odds > 0 {
      true => Float::from_int(american_odds) / 100.0,
      false => 100.0 / Float::from_int(american_odds * -1)
    },
    false => -1.0
  }
}

fn bet_type_name(bt: Int) Str {
  match bt {
    1 => "Money Line",
    16 => "Home Totals",
    17 => "Away Totals",
    27 => "Home Clean Sheet",
    28 => "Away Clean Sheet",
    _ => "Unknown"
  }
}

fn get_finished_fixtures(db: sql::Database, league_id: Int, season: Int) [fixtures::Fixture]!Str {
  let rows = try db.query("
    SELECT
      f.id,
      l.id as league_id,
      l.name as league_name,
      f.season,
      f.home_id,
      f.away_id,
      f.timestamp,
      f.finished,
      f.home_goals,
      f.away_goals,
      h.name as home_name,
      a.name as away_name
    FROM fixtures f
    INNER JOIN leagues l ON l.id = f.league_id
    INNER JOIN teams h ON h.id = f.home_id
    INNER JOIN teams a ON a.id = f.away_id
    WHERE f.league_id = @league_id
      AND f.season = @season
      AND f.finished = 1
    ORDER BY f.timestamp ASC
  ").all(["league_id": league_id, "season": season])

  mut fixture_list: [fixtures::Fixture] = []
  for row in rows {
    let f = try fixtures::from_row(row) -> errs { Result::err(errs.at(0).to_str()) }
    fixture_list.push(f)
  }
  Result::ok(fixture_list)
}

struct HistoricalPick {
  bet_type: Int,
  name: Str,
  odd: Int,
  ev_percentage: Float,
}

fn format_pct(val: Float) Str {
  let rounded = (val * 10.0).to_int()
  let whole = rounded / 10
  let frac = rounded - (whole * 10)
  match frac < 0 {
    true => "{whole}.{frac * -1}",
    false => "{whole}.{frac}"
  }
}

// Improved goal line probability estimation using simplified Poisson approximation
// For a Poisson distribution with mean λ, P(X > k) decreases as k increases
fn estimate_over_probability(expected_goals: Float, line: Float) Float {
  // Use a sigmoid-like function centered around the expected goals
  // P(over line) should be ~0.5 when line ≈ expected_goals
  let diff = expected_goals - line

  // Approximate probabilities based on difference from expected goals
  // These values are calibrated to match typical soccer goal distributions
  match {
    diff >= 1.5 => 0.90,
    diff >= 1.0 => 0.82,
    diff >= 0.5 => 0.70,
    diff >= 0.2 => 0.58,
    diff >= 0.0 => 0.50,
    diff >= -0.3 => 0.42,
    diff >= -0.5 => 0.35,
    diff >= -1.0 => 0.25,
    diff >= -1.5 => 0.15,
    diff >= -2.0 => 0.08,
    diff >= -2.5 => 0.04,
    _ => 0.02
  }
}

fn estimate_under_probability(expected_goals: Float, line: Float) Float {
  1.0 - estimate_over_probability(expected_goals, line)
}

fn simulate_picks(comp: predictions::Comparison, all_odds: [odds::Stat], verbose: Bool, fixture_id: Int) [HistoricalPick] {
  mut picks: [HistoricalPick] = []

  if verbose {
    io::print("    [DEBUG] Home xgf={format_pct(comp.home.xgf)} xga={format_pct(comp.home.xga)} win_rate={format_pct(comp.home.win_rate)}")
    io::print("    [DEBUG] Away xgf={format_pct(comp.away.xgf)} xga={format_pct(comp.away.xga)} win_rate={format_pct(comp.away.win_rate)}")
  }

  for odd in all_odds {
    if odd.id == odds::OUTCOME {
      for pick in odd.values {
        let is_home = pick.name == "Home"
        let is_away = pick.name == "Away"
        let is_draw = pick.name == "Draw"

        let home_draw_rate = Float::from_int(comp.home.draws) / Float::from_int(comp.home.num_games)
        let away_draw_rate = Float::from_int(comp.away.draws) / Float::from_int(comp.away.num_games)

        let base_prob = match {
          is_home => comp.home.win_rate,
          is_away => comp.away.win_rate,
          is_draw => (home_draw_rate + away_draw_rate) / 2.0,
          _ => 0.33
        }

        let should_boost = match {
          is_home => comp.home.goals_diff > 0 and comp.away.goals_diff < 0,
          is_away => comp.away.goals_diff > 0 and comp.home.goals_diff < 0,
          _ => false
        }

        let boosted = base_prob + 0.1
        let capped = match boosted > 0.85 {
          true => 0.85,
          false => boosted
        }
        let true_prob = match should_boost {
          true => capped,
          false => base_prob
        }

        let ev_result = predictions::calculate_ev(true_prob, pick.odd)
        if verbose {
          io::print("    [OUTCOME] {pick.name}: odd={pick.odd} prob={format_pct(true_prob * 100.0)}% ev={format_pct(ev_result.ev_percentage)}%")
        }
        if ev_result.ev_percentage >= predictions::MIN_EV_THRESHOLD {
          picks.push(HistoricalPick{
            bet_type: odd.id,
            name: pick.name,
            odd: pick.odd,
            ev_percentage: ev_result.ev_percentage
          })
        }
      }
    }

    if odd.id == odds::HOME_TOTAL_GOALS {
      let expected_goals = (comp.home.xgf + comp.away.xga) / 2.0
      if verbose {
        io::print("    [HOME_TOTALS] expected_goals={format_pct(expected_goals)}")
      }
      for line in odd.values {
        let line_value = parse_line(line.name)
        let is_over = line.name.starts_with("Over")
        let true_prob = match is_over {
          true => estimate_over_probability(expected_goals, line_value),
          false => estimate_under_probability(expected_goals, line_value)
        }
        let ev_result = predictions::calculate_ev(true_prob, line.odd)
        if verbose {
          io::print("      {line.name}: odd={line.odd} prob={format_pct(true_prob * 100.0)}% ev={format_pct(ev_result.ev_percentage)}%")
        }
        if ev_result.ev_percentage >= predictions::MIN_EV_THRESHOLD {
          picks.push(HistoricalPick{
            bet_type: odd.id,
            name: line.name,
            odd: line.odd,
            ev_percentage: ev_result.ev_percentage
          })
        }
      }
    }

    if odd.id == odds::AWAY_TOTAL_GOALS {
      let expected_goals = (comp.away.xgf + comp.home.xga) / 2.0
      if verbose {
        io::print("    [AWAY_TOTALS] expected_goals={format_pct(expected_goals)}")
      }
      for line in odd.values {
        let line_value = parse_line(line.name)
        let is_over = line.name.starts_with("Over")
        let true_prob = match is_over {
          true => estimate_over_probability(expected_goals, line_value),
          false => estimate_under_probability(expected_goals, line_value)
        }
        let ev_result = predictions::calculate_ev(true_prob, line.odd)
        if verbose {
          io::print("      {line.name}: odd={line.odd} prob={format_pct(true_prob * 100.0)}% ev={format_pct(ev_result.ev_percentage)}%")
        }
        if ev_result.ev_percentage >= predictions::MIN_EV_THRESHOLD {
          picks.push(HistoricalPick{
            bet_type: odd.id,
            name: line.name,
            odd: line.odd,
            ev_percentage: ev_result.ev_percentage
          })
        }
      }
    }

    if odd.id == odds::HOME_CLEANSHEET {
      for line in odd.values {
        let is_yes = line.name == "Yes"
        let true_prob = predictions::estimate_cleansheet_probability(comp.home.xga, comp.away.xgf, is_yes)
        let ev_result = predictions::calculate_ev(true_prob, line.odd)
        if verbose {
          io::print("    [HOME_CS] {line.name}: odd={line.odd} prob={format_pct(true_prob * 100.0)}% ev={format_pct(ev_result.ev_percentage)}%")
        }
        if ev_result.ev_percentage >= predictions::MIN_EV_THRESHOLD {
          picks.push(HistoricalPick{
            bet_type: odd.id,
            name: line.name,
            odd: line.odd,
            ev_percentage: ev_result.ev_percentage
          })
        }
      }
    }

    if odd.id == odds::AWAY_CLEANSHEET {
      for line in odd.values {
        let is_yes = line.name == "Yes"
        let true_prob = predictions::estimate_cleansheet_probability(comp.away.xga, comp.home.xgf, is_yes)
        let ev_result = predictions::calculate_ev(true_prob, line.odd)
        if verbose {
          io::print("    [AWAY_CS] {line.name}: odd={line.odd} prob={format_pct(true_prob * 100.0)}% ev={format_pct(ev_result.ev_percentage)}%")
        }
        if ev_result.ev_percentage >= predictions::MIN_EV_THRESHOLD {
          picks.push(HistoricalPick{
            bet_type: odd.id,
            name: line.name,
            odd: line.odd,
            ev_percentage: ev_result.ev_percentage
          })
        }
      }
    }
  }

  picks
}

fn aggregate_results(results: [BetResult], tested: Int, skipped: Int, season: Int) BacktestResult {
  mut type_stats: [Int:BetTypeStats] = [:]
  mut total_wins = 0
  mut total_losses = 0
  mut total_payout = 0.0
  mut total_ev = 0.0

  for r in results {
    total_ev =+ r.ev_percentage

    let is_win = r.actual_outcome == "win"
    if is_win { total_wins =+ 1 } else { total_losses =+ 1 }
    total_payout =+ r.payout

    match type_stats.get(r.bet_type) {
      existing => {
        let new_wins = match is_win {
          true => existing.wins + 1,
          false => existing.wins
        }
        let new_losses = match is_win {
          false => existing.losses + 1,
          true => existing.losses
        }
        type_stats.set(r.bet_type, BetTypeStats{
          bet_type: r.bet_type,
          name: existing.name,
          picks: existing.picks + 1,
          wins: new_wins,
          losses: new_losses,
          win_rate: 0.0,
          roi: existing.roi + r.payout,
          avg_ev: existing.avg_ev + r.ev_percentage,
        })
      },
      _ => {
        let init_wins = match is_win {
          true => 1,
          false => 0
        }
        let init_losses = match is_win {
          false => 1,
          true => 0
        }
        type_stats.set(r.bet_type, BetTypeStats{
          bet_type: r.bet_type,
          name: bet_type_name(r.bet_type),
          picks: 1,
          wins: init_wins,
          losses: init_losses,
          win_rate: 0.0,
          roi: r.payout,
          avg_ev: r.ev_percentage,
        })
      }
    }
  }

  mut by_bet_type: [BetTypeStats] = []
  for bt, stats in type_stats {
    let win_rate = match stats.picks > 0 {
      true => Float::from_int(stats.wins) / Float::from_int(stats.picks) * 100.0,
      false => 0.0
    }
    let roi = match stats.picks > 0 {
      true => stats.roi / Float::from_int(stats.picks) * 100.0,
      false => 0.0
    }
    let avg_ev = match stats.picks > 0 {
      true => stats.avg_ev / Float::from_int(stats.picks),
      false => 0.0
    }
    by_bet_type.push(BetTypeStats{
      bet_type: stats.bet_type,
      name: stats.name,
      picks: stats.picks,
      wins: stats.wins,
      losses: stats.losses,
      win_rate: win_rate,
      roi: roi,
      avg_ev: avg_ev,
    })
  }

  let total_picks = total_wins + total_losses
  let overall_win_rate = match total_picks > 0 {
    true => Float::from_int(total_wins) / Float::from_int(total_picks) * 100.0,
    false => 0.0
  }
  let overall_roi = match total_picks > 0 {
    true => total_payout / Float::from_int(total_picks) * 100.0,
    false => 0.0
  }

  BacktestResult{
    season: season,
    fixtures_tested: tested,
    fixtures_skipped: skipped,
    total_picks: total_picks,
    by_bet_type: by_bet_type,
    overall_win_rate: overall_win_rate,
    overall_roi: overall_roi,
  }
}

fn process_fixture(db: sql::Database, fixture: fixtures::Fixture, league_id: Int, season: Int, mut results: [BetResult], verbose: Bool) Bool {
  let home_form_result = get_form_as_of(db, fixture.home.id, league_id, season, fixture.timestamp)
  let away_form_result = get_form_as_of(db, fixture.away.id, league_id, season, fixture.timestamp)

  match home_form_result.ok and away_form_result.ok {
    false => {
      if verbose {
        let home_status = match home_form_result.ok {
          true => "ok",
          false => "MISSING"
        }
        let away_status = match away_form_result.ok {
          true => "ok",
          false => "MISSING"
        }
        io::print("  SKIP #{fixture.id} {fixture.home.name} vs {fixture.away.name}: home_form={home_status}, away_form={away_status}")
      }
      false
    },
    true => {
      let all_odds = try odds::get(db, fixture.id) -> err {
        if verbose {
          io::print("  SKIP #{fixture.id} {fixture.home.name} vs {fixture.away.name}: odds fetch error: {err}")
        }
        false
      }
      match all_odds.size() > 0 {
        false => {
          if verbose {
            io::print("  SKIP #{fixture.id} {fixture.home.name} vs {fixture.away.name}: no odds available")
          }
          false
        },
        true => {
          let home_form = home_form_result.snapshot
          let away_form = away_form_result.snapshot

          let home_venue_result = get_venue_stats_as_of(db, fixture.home.id, league_id, season, true, fixture.timestamp)
          let home_blended = match home_venue_result.ok {
            true => predictions::blend_snapshots(home_form, home_venue_result.snapshot),
            false => home_form
          }

          let away_venue_result = get_venue_stats_as_of(db, fixture.away.id, league_id, season, false, fixture.timestamp)
          let away_blended = match away_venue_result.ok {
            true => predictions::blend_snapshots(away_form, away_venue_result.snapshot),
            false => away_form
          }

          let comp = predictions::Comparison{ home: home_blended, away: away_blended }
          let picks = simulate_picks(comp, all_odds, verbose, fixture.id)

          if verbose and picks.size() > 0 {
            io::print("  TEST #{fixture.id} {fixture.home.name} vs {fixture.away.name} ({fixture.home_goals}-{fixture.away_goals}): {picks.size()} picks")
          }

          for pick in picks {
            let outcome = resolve_bet(pick.bet_type, pick.name, fixture)
            let payout = calculate_payout(pick.odd, outcome)
            results.push(BetResult{
              fixture_id: fixture.id,
              bet_type: pick.bet_type,
              pick_name: pick.name,
              pick_odd: pick.odd,
              ev_percentage: pick.ev_percentage,
              actual_outcome: outcome,
              payout: payout,
            })
          }

          true
        }
      }
    }
  }
}

fn run_backtest_with_options(db: sql::Database, season: Int, verbose: Bool, max_fixtures: Int) BacktestResult!Str {
  let all_leagues = try leagues::get_active(db)
  mut all_results: [BetResult] = []
  mut tested = 0
  mut skipped = 0
  mut total_processed = 0
  mut should_stop = false

  for league in all_leagues {
    if should_stop { () } else {
      io::print("Processing league: {league.name}")
      let fixture_list = try get_finished_fixtures(db, league.id, season)
      io::print("  {fixture_list.size()} fixtures")

      for fixture in fixture_list {
        if should_stop { () } else {
          // Stop early if max_fixtures is set and we've hit the limit
          if max_fixtures > 0 and total_processed >= max_fixtures {
            io::print("  (stopping - reached {max_fixtures} fixture limit)")
            should_stop = true
          } else {
            let success = process_fixture(db, fixture, league.id, season, all_results, verbose)
            match success {
              true => { tested =+ 1 },
              false => { skipped =+ 1 }
            }
            total_processed =+ 1
          }
        }
      }
    }
  }

  Result::ok(aggregate_results(all_results, tested, skipped, season))
}

fn run_backtest(db: sql::Database, season: Int) BacktestResult!Str {
  run_backtest_with_options(db, season, false, 0)
}

fn run_backtest_verbose(db: sql::Database, season: Int, max_fixtures: Int) BacktestResult!Str {
  run_backtest_with_options(db, season, true, max_fixtures)
}
