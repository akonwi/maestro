use ard/async
use ard/dates
use ard/decode
use ard/duration
use ard/env
use ard/fs
use ard/io
use ard/json
use ard/maybe
use ard/sql

use maestro/db as _db
use maestro/fapi
use maestro/fixtures
use maestro/leagues
use maestro/odds

let decode_id = decode::field("id", decode::int)
let decode_name = decode::field("name", decode::string)

struct Snapshot {
	num_games: Int,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,
	one_plus_scored: Int, // number of games in which team scored > 1 goal
	strike_rate: Float, // percentage of matches finding the net
	goals_diff: Int,
	xgf: Float,
	xga: Float,
	leakiness: Float,

	cleansheets: Int,
	one_conceded: Int,

	// could be presented as +1.5
	two_plus_conceded: Int,

	win_rate: Float,
}

impl Snapshot {
  fn to_dyn() Dynamic {
    Dynamic::object([
      "num_games": Dynamic::from(@num_games),
      "wins": Dynamic::from(@wins),
      "losses": Dynamic::from(@losses),
      "draws": Dynamic::from(@draws),
      "goals_against": Dynamic::from(@goals_against),
      "goals_for": Dynamic::from(@goals_for),
      "one_plus_scored": Dynamic::from(@one_plus_scored),
      "strike_rate": Dynamic::from(@strike_rate),
      "goals_diff": Dynamic::from(@goals_diff),
      "xgf": Dynamic::from(@xgf),
      "xga": Dynamic::from(@xga),
      "leakiness": Dynamic::from(@leakiness),
      "cleansheets": Dynamic::from(@cleansheets),
      "one_conceded": Dynamic::from(@one_conceded),
      "two_plus_conceded": Dynamic::from(@two_plus_conceded),
      "win_rate": Dynamic::from(@win_rate),
    ])
  }
}

struct Comparison {
  home: Snapshot,
  away: Snapshot,
}

fn get_comparison(db: sql::Database, fixture_id: Int) Comparison!Str {
  let body = try fapi::get_predictions(db, fixture_id)

  fn decode_stats(data: Dynamic) Snapshot![decode::Error] {
    let name = try decode_name(data)
    let league_data = try decode::extract_field(data, "league") -> found {
      Result::err([decode::Error{
        expected: "Field",
        found: found,
        path: ["league"]
      }])
    }
    let num_played = try decode::run(league_data, decode::path(["fixtures", "played", "total"], decode::int))
    let wins = try decode::run(league_data, decode::path(["fixtures", "wins", "total"], decode::int))
    let losses = try decode::run(league_data, decode::path(["fixtures", "loses", "total"], decode::int))
    let draws = try decode::run(league_data, decode::path(["fixtures", "draws", "total"], decode::int))
    let goals_against = try decode::run(league_data, decode::path(["goals", "against", "total", "total"], decode::int))
    let xga = Float::from_int(goals_against) / Float::from_int(num_played)
    let goals_for = try decode::run(league_data, decode::path(["goals", "for", "total", "total"], decode::int))
    let xgf = Float::from_int(goals_for) / Float::from_int(num_played)
    let one_plus_scored = try decode::run(league_data, decode::path(["goals", "for", "under_over", "1.5", "over"], decode::int))
    let no_score = try decode::run(league_data, decode::path(["failed_to_score", "total"], decode::int))
    let cleansheets = try decode::run(league_data, decode::path(["clean_sheet", "total"], decode::int))
    let at_least_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "0.5", "over"], decode::int))
    let over_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "1.5", "over"], decode::int))
    let one_conceded = at_least_1_against - over_1_against
    let two_plus_conceded = over_1_against

    Result::ok(Snapshot{
      num_games: num_played,
      wins: wins,
      losses: losses,
      draws: draws,
      goals_against: goals_against,
      xga: xga,
      goals_for: goals_for,
      one_plus_scored: one_plus_scored,
      strike_rate: 1.0 - Float::from_int(no_score) / Float::from_int(num_played),
      xgf: xgf,
      goals_diff: goals_for - goals_against,
      cleansheets: cleansheets,
      one_conceded: one_conceded,
      two_plus_conceded: two_plus_conceded,
      leakiness: Float::from_int(two_plus_conceded) / Float::from_int(num_played) * 100.0,
      win_rate: Float::from_int(wins) / Float::from_int(num_played),
    })
  }

  fn decode_comparison(data: Dynamic) Comparison![decode::Error] {
    let home = try decode::run(data, decode::field("home", decode_stats))
    let away = try decode::run(data, decode::field("away", decode_stats))

    Result::ok(Comparison{
      home: home,
      away: away,
    })
  }

  let comparison = try decode::run(body, decode::field("response", decode::at(0, decode::field("teams", decode_comparison)))) -> errs {
    Result::err(errs.at(0).to_str())
  }

  Result::ok(comparison)
}
