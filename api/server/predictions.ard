use ard/async
use ard/dates
use ard/decode
use ard/duration
use ard/env
use ard/fs
use ard/io
use ard/json
use ard/maybe
use ard/sql

use maestro/db as _db
use maestro/fapi
use maestro/fixtures
use maestro/leagues
use maestro/odds

let decode_id = decode::field("id", decode::int)
let decode_name = decode::field("name", decode::string)

// Minimum EV percentage to recommend a bet (5%)
let MIN_EV_THRESHOLD = 5.0

// Form weight for blending (60% form, 40% season venue stats)
let FORM_WEIGHT = 0.6

// Convert American odds to implied probability
// Positive odds (+150): 100 / (odds + 100) = 40%
// Negative odds (-110): |odds| / (|odds| + 100) = 52.4%
fn odds_to_implied_probability(american_odds: Int) Float {
  match american_odds > 0 {
    true => 100.0 / Float::from_int(american_odds + 100),
    false => {
      let abs_odds = american_odds * -1
      Float::from_int(abs_odds) / Float::from_int(abs_odds + 100)
    }
  }
}

struct EVResult {
  ev: Float,
  ev_percentage: Float,
  true_win_prob: Float,
  implied_prob: Float,
  edge: Float,
}

// Calculate expected value given true probability and American odds
// EV = (true_prob × win_amount) - (loss_prob × stake)
// Reference: https://www.pinnacle.com/betting-resources/en/betting-strategy/how-to-calculate-expected-value/ees2ve46tm4htt32
fn calculate_ev(true_win_prob: Float, american_odds: Int) EVResult {
  // Convert to decimal odds for payout calculation
  let decimal_odds = match american_odds > 0 {
    true => Float::from_int(american_odds) / 100.0 + 1.0,
    false => 100.0 / Float::from_int(american_odds * -1) + 1.0
  }

  let win_amount = decimal_odds - 1.0  // Profit on $1 bet
  let loss_prob = 1.0 - true_win_prob

  let ev = (true_win_prob * win_amount) - (loss_prob * 1.0)
  let implied_prob = odds_to_implied_probability(american_odds)

  EVResult{
    ev: ev,
    ev_percentage: ev * 100.0,
    true_win_prob: true_win_prob,
    implied_prob: implied_prob,
    edge: true_win_prob - implied_prob,
  }
}

// Simple probability estimation based on xG difference from line
// Phase 1: threshold-based buckets, will be refined in Phase 2
fn estimate_goal_line_probability(expected_goals: Float, line: Float, is_over: Bool) Float {
  let diff = match is_over {
    true => expected_goals - line,
    false => line - expected_goals
  }
  match {
    diff >= 0.5 => 0.72,
    diff >= 0.3 => 0.62,
    diff >= 0.0 => 0.52,
    _ => 0.42
  }
}

// Estimate probability for clean sheet bets
fn estimate_cleansheet_probability(team_xga: Float, opponent_xgf: Float, is_yes: Bool) Float {
  let opponent_attack = (opponent_xgf + team_xga) / 2.0
  match is_yes {
    true => {
      // Clean sheet YES - need strong defense AND weak opponent
      match {
        opponent_attack <= 0.8 => 0.65,
        opponent_attack <= 1.0 => 0.55,
        opponent_attack <= 1.2 => 0.45,
        _ => 0.35
      }
    },
    false => {
      // Clean sheet NO - opponent likely to score
      match {
        opponent_attack >= 1.5 => 0.75,
        opponent_attack >= 1.2 => 0.65,
        opponent_attack >= 1.0 => 0.55,
        _ => 0.45
      }
    }
  }
}

struct Snapshot {
	num_games: Int,
	wins: Int,
	losses: Int,
	draws:  Int,

	goals_against: Int,
	goals_for: Int,
	one_plus_scored: Int, // number of games in which team scored > 1 goal
	strike_rate: Float, // percentage of matches finding the net
	goals_diff: Int,
	xgf: Float,
	xga: Float,
	leakiness: Float,

	cleansheets: Int,
	one_conceded: Int,

	// could be presented as +1.5
	two_plus_conceded: Int,

	win_rate: Float,
}

impl Snapshot {
  fn to_dyn() Dynamic {
    Dynamic::object([
      "num_games": Dynamic::from(@num_games),
      "wins": Dynamic::from(@wins),
      "losses": Dynamic::from(@losses),
      "draws": Dynamic::from(@draws),
      "goals_against": Dynamic::from(@goals_against),
      "goals_for": Dynamic::from(@goals_for),
      "one_plus_scored": Dynamic::from(@one_plus_scored),
      "strike_rate": Dynamic::from(@strike_rate),
      "goals_diff": Dynamic::from(@goals_diff),
      "xgf": Dynamic::from(@xgf),
      "xga": Dynamic::from(@xga),
      "leakiness": Dynamic::from(@leakiness),
      "cleansheets": Dynamic::from(@cleansheets),
      "one_conceded": Dynamic::from(@one_conceded),
      "two_plus_conceded": Dynamic::from(@two_plus_conceded),
      "win_rate": Dynamic::from(@win_rate),
    ])
  }
}

struct Comparison {
  home: Snapshot,
  away: Snapshot,
}

fn get_comparison(db: sql::Database, fixture_id: Int) Comparison!Str {
  let body = try fapi::get_predictions(db, fixture_id)

  fn decode_stats(data: Dynamic) Snapshot![decode::Error] {
    let name = try decode_name(data)
    let league_data = try decode::extract_field(data, "league") -> found {
      Result::err([decode::Error{
        expected: "Field",
        found: found,
        path: ["league"]
      }])
    }
    let num_played = try decode::run(league_data, decode::path(["fixtures", "played", "total"], decode::int))
    let wins = try decode::run(league_data, decode::path(["fixtures", "wins", "total"], decode::int))
    let losses = try decode::run(league_data, decode::path(["fixtures", "loses", "total"], decode::int))
    let draws = try decode::run(league_data, decode::path(["fixtures", "draws", "total"], decode::int))
    let goals_against = try decode::run(league_data, decode::path(["goals", "against", "total", "total"], decode::int))
    let xga = Float::from_int(goals_against) / Float::from_int(num_played)
    let goals_for = try decode::run(league_data, decode::path(["goals", "for", "total", "total"], decode::int))
    let xgf = Float::from_int(goals_for) / Float::from_int(num_played)
    let one_plus_scored = try decode::run(league_data, decode::path(["goals", "for", "under_over", "1.5", "over"], decode::int))
    let no_score = try decode::run(league_data, decode::path(["failed_to_score", "total"], decode::int))
    let cleansheets = try decode::run(league_data, decode::path(["clean_sheet", "total"], decode::int))
    let at_least_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "0.5", "over"], decode::int))
    let over_1_against = try decode::run(league_data, decode::path(["goals", "against", "under_over", "1.5", "over"], decode::int))
    let one_conceded = at_least_1_against - over_1_against
    let two_plus_conceded = over_1_against

    Result::ok(Snapshot{
      num_games: num_played,
      wins: wins,
      losses: losses,
      draws: draws,
      goals_against: goals_against,
      xga: xga,
      goals_for: goals_for,
      one_plus_scored: one_plus_scored,
      strike_rate: 1.0 - Float::from_int(no_score) / Float::from_int(num_played),
      xgf: xgf,
      goals_diff: goals_for - goals_against,
      cleansheets: cleansheets,
      one_conceded: one_conceded,
      two_plus_conceded: two_plus_conceded,
      leakiness: Float::from_int(two_plus_conceded) / Float::from_int(num_played) * 100.0,
      win_rate: Float::from_int(wins) / Float::from_int(num_played),
    })
  }

  fn decode_comparison(data: Dynamic) Comparison![decode::Error] {
    let home = try decode::run(data, decode::field("home", decode_stats))
    let away = try decode::run(data, decode::field("away", decode_stats))

    Result::ok(Comparison{
      home: home,
      away: away,
    })
  }

  let comparison = try decode::run(body, decode::field("response", decode::at(0, decode::field("teams", decode_comparison)))) -> errs {
    Result::err(errs.at(0).to_str())
  }

  Result::ok(comparison)
}

// Constructs a Snapshot from raw counter values, computing derived stats like
// strike_rate, xgf/xga averages, leakiness, one_conceded, and win_rate.
// Returns an empty snapshot with zeroed values if games_counted is 0.
fn build_snapshot(
  games_counted: Int,
  wins: Int,
  losses: Int,
  draws: Int,
  goals_for: Int,
  goals_against: Int,
  xg_for_total: Float,
  xg_against_total: Float,
  one_plus_scored: Int,
  cleansheets: Int,
  failed_to_score: Int,
  at_least_1_against: Int,
  two_plus_conceded: Int
) Snapshot {
  match games_counted == 0 {
    true => Snapshot{
      num_games: 0,
      wins: 0,
      losses: 0,
      draws: 0,
      goals_against: 0,
      goals_for: 0,
      one_plus_scored: 0,
      strike_rate: 0.0,
      goals_diff: 0,
      xgf: 0.0,
      xga: 0.0,
      leakiness: 0.0,
      cleansheets: 0,
      one_conceded: 0,
      two_plus_conceded: 0,
      win_rate: 0.0,
    },
    false => {
      let games = Float::from_int(games_counted)
      let xgf = xg_for_total / games
      let xga = xg_against_total / games
      let one_conceded = at_least_1_against - two_plus_conceded

      Snapshot{
        num_games: games_counted,
        wins: wins,
        losses: losses,
        draws: draws,
        goals_against: goals_against,
        goals_for: goals_for,
        one_plus_scored: one_plus_scored,
        strike_rate: 1.0 - Float::from_int(failed_to_score) / games,
        goals_diff: goals_for - goals_against,
        xgf: xgf,
        xga: xga,
        leakiness: Float::from_int(two_plus_conceded) / games * 100.0,
        cleansheets: cleansheets,
        one_conceded: one_conceded,
        two_plus_conceded: two_plus_conceded,
        win_rate: Float::from_int(wins) / games,
      }
    }
  }
}

struct TeamSeasonStats {
  overall: Snapshot,
  home_only: Snapshot,
  away_only: Snapshot,
}

impl TeamSeasonStats {
  fn to_dyn() Dynamic {
    Dynamic::object([
      "overall": @overall.to_dyn(),
      "home_only": @home_only.to_dyn(),
      "away_only": @away_only.to_dyn(),
    ])
  }
}

// Computes stats split by home/away in a single pass
fn compute_season_stats(fixture_stats_list: [fixtures::FixtureStats], team_id: Int) TeamSeasonStats {
  // Overall counters
  mut all_wins = 0
  mut all_losses = 0
  mut all_draws = 0
  mut all_goals_for = 0
  mut all_goals_against = 0
  mut all_xg_for = 0.0
  mut all_xg_against = 0.0
  mut all_one_plus_scored = 0
  mut all_cleansheets = 0
  mut all_failed_to_score = 0
  mut all_at_least_1_against = 0
  mut all_two_plus_conceded = 0
  mut all_games = 0

  // Home-only counters
  mut home_wins = 0
  mut home_losses = 0
  mut home_draws = 0
  mut home_goals_for = 0
  mut home_goals_against = 0
  mut home_xg_for = 0.0
  mut home_xg_against = 0.0
  mut home_one_plus_scored = 0
  mut home_cleansheets = 0
  mut home_failed_to_score = 0
  mut home_at_least_1_against = 0
  mut home_two_plus_conceded = 0
  mut home_games = 0

  // Away-only counters
  mut away_wins = 0
  mut away_losses = 0
  mut away_draws = 0
  mut away_goals_for = 0
  mut away_goals_against = 0
  mut away_xg_for = 0.0
  mut away_xg_against = 0.0
  mut away_one_plus_scored = 0
  mut away_cleansheets = 0
  mut away_failed_to_score = 0
  mut away_at_least_1_against = 0
  mut away_two_plus_conceded = 0
  mut away_games = 0

  for fs in fixture_stats_list {
    let is_home = fs.fixture.home.id == team_id

    let team_stats = match is_home {
      true => fs.home,
      false => fs.away
    }
    let opp_stats = match is_home {
      true => fs.away,
      false => fs.home
    }
    let team_goals = match is_home {
      true => fs.fixture.home_goals,
      false => fs.fixture.away_goals
    }
    let opp_goals = match is_home {
      true => fs.fixture.away_goals,
      false => fs.fixture.home_goals
    }

    // Update overall
    all_games =+ 1
    all_goals_for =+ team_goals
    all_goals_against =+ opp_goals
    all_xg_for =+ team_stats.xg
    all_xg_against =+ opp_stats.xg
    if team_goals == 0 { all_failed_to_score =+ 1 }
    if opp_goals == 0 { all_cleansheets =+ 1 }
    if team_goals > 1 { all_one_plus_scored =+ 1 }
    if opp_goals >= 1 { all_at_least_1_against =+ 1 }
    if opp_goals >= 2 { all_two_plus_conceded =+ 1 }
    match {
      team_goals > opp_goals => { all_wins =+ 1 },
      team_goals < opp_goals => { all_losses =+ 1 },
      _ => { all_draws =+ 1 }
    }

    // Update home or away bucket
    match is_home {
      true => {
        home_games =+ 1
        home_goals_for =+ team_goals
        home_goals_against =+ opp_goals
        home_xg_for =+ team_stats.xg
        home_xg_against =+ opp_stats.xg
        if team_goals == 0 { home_failed_to_score =+ 1 }
        if opp_goals == 0 { home_cleansheets =+ 1 }
        if team_goals > 1 { home_one_plus_scored =+ 1 }
        if opp_goals >= 1 { home_at_least_1_against =+ 1 }
        if opp_goals >= 2 { home_two_plus_conceded =+ 1 }
        match {
          team_goals > opp_goals => { home_wins =+ 1 },
          team_goals < opp_goals => { home_losses =+ 1 },
          _ => { home_draws =+ 1 }
        }
      },
      false => {
        away_games =+ 1
        away_goals_for =+ team_goals
        away_goals_against =+ opp_goals
        away_xg_for =+ team_stats.xg
        away_xg_against =+ opp_stats.xg
        if team_goals == 0 { away_failed_to_score =+ 1 }
        if opp_goals == 0 { away_cleansheets =+ 1 }
        if team_goals > 1 { away_one_plus_scored =+ 1 }
        if opp_goals >= 1 { away_at_least_1_against =+ 1 }
        if opp_goals >= 2 { away_two_plus_conceded =+ 1 }
        match {
          team_goals > opp_goals => { away_wins =+ 1 },
          team_goals < opp_goals => { away_losses =+ 1 },
          _ => { away_draws =+ 1 }
        }
      }
    }
  }

  TeamSeasonStats{
    overall: build_snapshot(all_games, all_wins, all_losses, all_draws, all_goals_for, all_goals_against, all_xg_for, all_xg_against, all_one_plus_scored, all_cleansheets, all_failed_to_score, all_at_least_1_against, all_two_plus_conceded),
    home_only: build_snapshot(home_games, home_wins, home_losses, home_draws, home_goals_for, home_goals_against, home_xg_for, home_xg_against, home_one_plus_scored, home_cleansheets, home_failed_to_score, home_at_least_1_against, home_two_plus_conceded),
    away_only: build_snapshot(away_games, away_wins, away_losses, away_draws, away_goals_for, away_goals_against, away_xg_for, away_xg_against, away_one_plus_scored, away_cleansheets, away_failed_to_score, away_at_least_1_against, away_two_plus_conceded),
  }
}

fn get_team_season_stats(db: sql::Database, team_id: Int, league_id: Int, season: Int) TeamSeasonStats!Str {
  let entries = try fapi::get_team_played_fixtures(db, team_id: team_id, league_id: league_id, season: season, last: maybe::none())

  mut fixture_stats_list: [fixtures::FixtureStats] = []
  for e in entries {
    let fixture_id = try decode::run(e, decode::path(["fixture", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }
    let data = try fapi::get_fixture(db, fixture_id)
    let fs = try fixtures::decode_stats(data) -> errs { Result::err("Unable to decode fixture {fixture_id}: {fixtures::collapse_errors("", errs)}") }
    fixture_stats_list.push(fs)
  }

  Result::ok(compute_season_stats(fixture_stats_list, team_id))
}

// Blend form stats with venue-specific season stats
// form_weight: 0.0-1.0, higher = more weight on recent form
fn blend_snapshots(form: Snapshot, season_venue: Snapshot) Snapshot {
  let fw = FORM_WEIGHT
  let sw = 1.0 - fw

  // Blend the key metrics
  let blended_xgf = (form.xgf * fw) + (season_venue.xgf * sw)
  let blended_xga = (form.xga * fw) + (season_venue.xga * sw)
  let blended_win_rate = (form.win_rate * fw) + (season_venue.win_rate * sw)
  let blended_strike_rate = (form.strike_rate * fw) + (season_venue.strike_rate * sw)
  let blended_leakiness = (form.leakiness * fw) + (season_venue.leakiness * sw)

  // For counts, use form values (more recent/relevant)
  Snapshot{
    num_games: form.num_games,
    wins: form.wins,
    losses: form.losses,
    draws: form.draws,
    goals_against: form.goals_against,
    goals_for: form.goals_for,
    one_plus_scored: form.one_plus_scored,
    strike_rate: blended_strike_rate,
    goals_diff: form.goals_diff,
    xgf: blended_xgf,
    xga: blended_xga,
    leakiness: blended_leakiness,
    cleansheets: form.cleansheets,
    one_conceded: form.one_conceded,
    two_plus_conceded: form.two_plus_conceded,
    win_rate: blended_win_rate,
  }
}

// Extract venue stats from season stats
fn get_venue_snapshot(stats: TeamSeasonStats, is_home: Bool) Snapshot {
  match is_home {
    true => stats.home_only,
    false => stats.away_only
  }
}

// Helper to get season stats and blend with form, falling back to form if stats unavailable
fn blend_with_venue(db: sql::Database, form: Snapshot, team_id: Int, league_id: Int, season: Int, is_home: Bool) Snapshot {
  match get_team_season_stats(db, team_id, league_id, season) {
    ok(stats) => blend_snapshots(form, get_venue_snapshot(stats, is_home)),
    err(_) => form
  }
}

// returns metrics over the last 5 games before the given timestamp
// todo: this should support a timestamp or date so that it can provide form at that point
fn get_form(db: sql::Database, team_id: Int, league_id: Int, season: Int) Snapshot!Str {
  let entries = try fapi::get_team_played_fixtures(db, team_id: team_id, league_id: league_id, season: season, last: maybe::some(5))

  mut fixture_stats_list: [fixtures::FixtureStats] = []
  for e in entries {
    let fixture_id = try decode::run(e, decode::path(["fixture", "id"], decode::int)) -> errs { Result::err(errs.at(0).to_str()) }

    let data = try fapi::get_fixture(db, fixture_id)
    let fs = try fixtures::decode_stats(data) -> errs { Result::err("Unable to decode fixture {fixture_id}: {fixtures::collapse_errors("", errs)}") }
    fixture_stats_list.push(fs)
  }

  mut wins = 0
  mut losses = 0
  mut draws = 0
  mut goals_for = 0
  mut goals_against = 0
  mut xg_for_total = 0.0
  mut xg_against_total = 0.0
  mut one_plus_scored = 0
  mut cleansheets = 0
  mut failed_to_score = 0
  mut at_least_1_against = 0
  mut two_plus_conceded = 0

  for fs in fixture_stats_list {
    let is_home = fs.fixture.home.id == team_id

    let team_stats = match is_home {
      true => fs.home,
      false => fs.away
    }
    let opp_stats = match is_home {
      true => fs.away,
      false => fs.home
    }

    let team_goals = match is_home {
      true => fs.fixture.home_goals,
      false => fs.fixture.away_goals
    }
    let opp_goals = match is_home {
      true => fs.fixture.away_goals,
      false => fs.fixture.home_goals
    }

    goals_for =+ team_goals
    goals_against =+ opp_goals
    xg_for_total =+ team_stats.xg
    xg_against_total =+ opp_stats.xg

    if team_goals == 0 { failed_to_score =+ 1 }
    if opp_goals == 0 { cleansheets =+ 1 }
    if team_goals > 1 { one_plus_scored =+ 1 }
    if opp_goals >= 1 { at_least_1_against =+ 1 }
    if opp_goals >= 2 { two_plus_conceded =+ 1 }

    match {
      team_goals > opp_goals => { wins =+ 1 },
      team_goals < opp_goals => { losses =+ 1 },
      _ => { draws =+ 1 }
    }
  }

  let num_games = fixture_stats_list.size()
  match num_games == 0 {
    true => Result::ok(Snapshot{
      num_games: 0,
      wins: 0,
      losses: 0,
      draws: 0,
      goals_against: 0,
      goals_for: 0,
      one_plus_scored: 0,
      strike_rate: 0.0,
      goals_diff: 0,
      xgf: 0.0,
      xga: 0.0,
      leakiness: 0.0,
      cleansheets: 0,
      one_conceded: 0,
      two_plus_conceded: 0,
      win_rate: 0.0,
    }),
    false => {
      let games = Float::from_int(num_games)
      let xgf = xg_for_total / games
      let xga = xg_against_total / games
      let one_conceded = at_least_1_against - two_plus_conceded

      Result::ok(Snapshot{
        num_games: num_games,
        wins: wins,
        losses: losses,
        draws: draws,
        goals_against: goals_against,
        goals_for: goals_for,
        one_plus_scored: one_plus_scored,
        strike_rate: 1.0 - Float::from_int(failed_to_score) / games,
        goals_diff: goals_for - goals_against,
        xgf: xgf,
        xga: xga,
        leakiness: Float::from_int(two_plus_conceded) / games * 100.0,
        cleansheets: cleansheets,
        one_conceded: one_conceded,
        two_plus_conceded: two_plus_conceded,
        win_rate: Float::from_int(wins) / games,
      })
    }
  }
}

// Returns form-based comparison if league is followed and both teams have ≥5 games
// falls back to normal comparison for unfollowed leagues
fn get_form_comparison(db: sql::Database, fixture: fixtures::Fixture) Comparison!Str {
  let home_form = try get_form(db: db, team_id: fixture.home.id, league_id: fixture.league_id, season: fixture.season)
  let away_form = try get_form(db: db, team_id: fixture.away.id, league_id: fixture.league_id, season: fixture.season)

  Result::ok(Comparison{ home: home_form, away: away_form })
}

struct FixturePicks {
  fixture: fixtures::Fixture,
  stats: [odds::EVStat]
}

fn pick_outcome(odd: odds::Stat, comp: Comparison, mut entry: FixturePicks) {
  mut lines: [odds::EVLine] = []
  for pick in odd.values {
    // Estimate win probability based on win rates and goal difference
    let is_home = pick.name == "Home"
    let is_away = pick.name == "Away"
    let is_draw = pick.name == "Draw"

    // Calculate base probability and whether to boost
    let base_prob = match {
      is_home => comp.home.win_rate,
      is_away => comp.away.win_rate,
      is_draw => (Float::from_int(comp.home.draws) / Float::from_int(comp.home.num_games) + Float::from_int(comp.away.draws) / Float::from_int(comp.away.num_games)) / 2.0,
      _ => 0.33
    }

    let should_boost = match {
      is_home => comp.home.goals_diff > 0 and comp.away.goals_diff < 0,
      is_away => comp.away.goals_diff > 0 and comp.home.goals_diff < 0,
      _ => false
    }

    // Apply boost if applicable, cap at 0.85
    let boosted = base_prob + 0.1
    let capped = match boosted > 0.85 {
      true => 0.85,
      false => boosted
    }
    let true_prob = match should_boost {
      true => capped,
      false => base_prob
    }

    let ev_result = calculate_ev(true_prob, pick.odd)

    if ev_result.ev_percentage >= MIN_EV_THRESHOLD {
      lines.push(odds::EVLine{
        name: pick.name,
        odd: pick.odd,
        ev_percentage: ev_result.ev_percentage,
        true_win_prob: ev_result.true_win_prob,
        implied_prob: ev_result.implied_prob,
        edge: ev_result.edge,
      })
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::EVStat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn pick_team_goal_lines(odd: odds::Stat, team: Snapshot, opponent: Snapshot, mut entry: FixturePicks) {
  // Expected goals based on team attack vs opponent defense
  let expected_goals = (team.xgf + opponent.xga) / 2.0

  mut lines: [odds::EVLine] = []
  for line in odd.values {
    // Parse line value from name (e.g., "Over 1.5" -> 1.5)
    let line_value = match {
      line.name == "Over 0.5" or line.name == "Under 0.5" => 0.5,
      line.name == "Over 1.5" or line.name == "Under 1.5" => 1.5,
      line.name == "Over 2.5" or line.name == "Under 2.5" => 2.5,
      line.name == "Over 3.5" or line.name == "Under 3.5" => 3.5,
      _ => 0.0
    }

    let is_over = line.name.starts_with("Over")
    let true_prob = estimate_goal_line_probability(expected_goals, line_value, is_over)
    let ev_result = calculate_ev(true_prob, line.odd)

    if ev_result.ev_percentage >= MIN_EV_THRESHOLD {
      lines.push(odds::EVLine{
        name: line.name,
        odd: line.odd,
        ev_percentage: ev_result.ev_percentage,
        true_win_prob: ev_result.true_win_prob,
        implied_prob: ev_result.implied_prob,
        edge: ev_result.edge,
      })
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::EVStat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

fn pick_cleansheet_lines(odd: odds::Stat, team: Snapshot, opponent: Snapshot, mut entry: FixturePicks) {
  mut lines: [odds::EVLine] = []
  for line in odd.values {
    let is_yes = line.name == "Yes"
    let true_prob = estimate_cleansheet_probability(team.xga, opponent.xgf, is_yes)
    let ev_result = calculate_ev(true_prob, line.odd)

    if ev_result.ev_percentage >= MIN_EV_THRESHOLD {
      lines.push(odds::EVLine{
        name: line.name,
        odd: line.odd,
        ev_percentage: ev_result.ev_percentage,
        true_win_prob: ev_result.true_win_prob,
        implied_prob: ev_result.implied_prob,
        edge: ev_result.edge,
      })
    }
  }

  if lines.size() > 0 {
    entry.stats.push(odds::EVStat{
      id: odd.id,
      name: odd.name,
      values: lines
    })
  }
}

private fn save_juice(db: sql::Database, id: Str, raw: Str) Void!Str {
  io::print("Saving juice: {id}")
  let rows = try db.query("SELECT id FROM juice WHERE id = @id").first(["id": id])
  let sql = match rows.is_some() {
    true => "UPDATE juice SET raw_data = @raw WHERE id = @id",
    false => "INSERT INTO juice (id, raw_data) VALUES (@id, @raw)"
  }
  try db.query(sql).run(["id": id, "raw": raw]) -> err {
    let msg = "Error saving juice: {err}"
    io::print(msg)
    Result::err(msg)
  }
  Result::ok(())
}

private fn find_juice() {
  let db = _db::connect()
  let ignored_leagues = leagues::get_ignored(db)

  mut entries: [FixturePicks] = []
  for fixture in fixtures::find_today(db) {
    if not ignored_leagues.has(fixture.league.id) {
      match get_form_comparison(db, fixture) {
        ok(form) => {
          // Get season stats with venue splits for blending
          // If season stats fail, fall back to form-only (no blending)
          let home_blended = blend_with_venue(db, form.home, fixture.home.id, fixture.league.id, fixture.season, true)
          let away_blended = blend_with_venue(db, form.away, fixture.away.id, fixture.league.id, fixture.season, false)

          let comp = Comparison{
            home: home_blended,
            away: away_blended,
          }

          mut entry = FixturePicks{
            fixture: fixture,
            stats: [],
          }

          // find odds, if team over/under makes sense, save it
          match odds::get(db, fixture.id) {
            ok(all_odds) => {
              for odd in all_odds {
                if odd.id == odds::OUTCOME {
                  pick_outcome(odd, comp, entry)
                }

                if odd.id == odds::HOME_TOTAL_GOALS {
                  pick_team_goal_lines(odd, comp.home, comp.away, entry)
                }

                if odd.id == odds::AWAY_TOTAL_GOALS {
                  pick_team_goal_lines(odd, comp.away, comp.home, entry)
                }

                if odd.id == odds::HOME_CLEANSHEET {
                  pick_cleansheet_lines(odd, comp.home, comp.away, entry)
                }

                if odd.id == odds::AWAY_CLEANSHEET {
                  pick_cleansheet_lines(odd, comp.away, comp.home, entry)
                }
              }
            },
            err => io::print("Error getting odds for fixture {fixture.id}: {err}")
          }

          if entry.stats.size() > 0 {
            entries.push(entry)
          }
        },
        err => io::print("Error getting matchup data for fixture {fixture.id}: {err}")
      }
    }
  }

  io::print("Found {entries.size()} good bets")

  match json::encode(entries) {
    ok(content) => {
      save_juice(db, dates::get_today(), content)
    },
    err => io::print("Error encoding juice data to JSON: {err}")
  }

  db.close()
}

fn find_juice_worker() {
  while {
    find_juice()
    async::sleep(duration::from_hours(2))
  }
}

fn get_juice(db: sql::Database, date: Str) Str!Str {
  let id = match date.is_empty() {
    true => dates::get_today(),
    false => date
  }

  let row = try db.query("select * from juice where id = @id").first(["id": id])
  match row {
    row => {
      let raw = try decode::run(row, decode::field("raw_data", decode::string)) -> errs {
        Result::err(errs.at(0).to_str())
      }

      Result::ok(raw)
    },
    _ => Result::ok("[]"),
  }
}
